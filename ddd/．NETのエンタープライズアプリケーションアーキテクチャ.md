# 第1章 ソフトウェアアーキテクチャ

## アーキテクチャ

ソフトウェアの複雑性が高まり、開発コストが高い。
アークテクチャは顧客のためのシステムを構築する。

建築→できるだけ多くの人々に役立つように計画される。承認されたプロジェクトに対する変更コストが莫大である。
ソフトウェア→少数のステークホルダーのために作成される。要件の見直しや優先順位の変更などがひっきりなしに発生する。

## 標準的なソフトウェアアーキテクチャの定義

→ISO/IEC 42010:2011。ソフトウェア集約システムの構築方法に関係がある。ソフトウェア集約システムはステークホルダーの利害関係を尊重しつつ、問題を解決し、そのミッションを遂行するシステムです。

ステークホルダー（アーキテクト、開発者、テストスタッフ、取得者、エンドユーザー、アナリスト、監査人、最高情報責任者など）

ステークホルダー - 利害関係 -> システム -> アーキテクチャ <- アーキテクチャの説明
アーキテクチャを表現することは、開発のライフサイクルと完成したシステムの品質を左右する決断をする。

## 要件の承認

機能的（振る舞い）、非機能的（システムの特性）な特徴。

機能性→振る舞い。「いつどんな状況で何をどのように使ったときに、ニーズを満たしているかどうか」
信頼性→パフォーマンス、耐障害性、回復性
使用性→法令に準拠すること。ユーザーによって魅力的であること。
効率性→レスポンシブル。リソースのパフォーマンス。
保守性→安定性、変更性。
移植性→プラットフォーム移植性。

機能要件は後から発覚することも多い。そこで完全に理解される。実装に関するもの。
非機能要件はスケーラビリティ。セキュリティ、アクセシビリティ。アーキテクチャの選択によって決まる。
スケーラビリティを確保するには読み取りと書き込みの発生をできるだけ短い時間に抑える。
セキュリティを確保するには重要なモジュールを隔離されたマシンに配置する。
アクセシビリティ？？

非機能要件は実装戦略と技術選択に役立つ。

## 要件の収集

一つのことだけを取り上げる
明確に書かれている
企業やステークホルダーの要求をたどることができる
古くなっていないもの

ソフトウェア要求パターン

ビジネスサイド→開発者
省略されていたり忘れられていたりするところで要件の取りこぼしが生まれる
使う言葉が違うことが根底にある


## 要件の対処

要件のリストをカテゴライズする。
要件の少ないカテゴリについては収集不足が考えられるので再度調査をする必要がある。

## 何がアーキテクチャか

相互作用を必要とするコンポーネントを洗い出す。

概念的なアーキテクチャ
機能的・物理的なアーキテクチャ

大きなコンポーネントを小さく分解する。
仕様の内容と形式は開発手法に依存する。
アジャイル性が高いほど、アーキテクチャの実装時に開発者に与えられる自由度と主体性が高くなる。

## アーキテクチャと実装の境界線

コンポーネントは論理的な機能を表す。
インターフェース、役割、振る舞いの設計はアーキテクチャの目的

振る舞いのブラックボックス
置き換えやリファクタリングを簡単に行える部分
このブラックボックスの上にあるものは変更が困難なアーキテクチャの部分。
変更が困難な決断が全て適正なものであることがわかるアーキテクチャ

アーキテクチャはプロジェクトのできるだけ早い段階に正しく下す必要のあるもの。
それはいろんなところにある。

ビジネスロジックの構成の変更
ライブラリの変更
メンバーの修飾子の変更

技術選択。最適かどうかどうやって判断するのか。

## プロセス

マネジメント、開発、テストの3つの共同作業
マネジメント：仕様、品質の定義、スケジュール管理
開発：コーディング
テスト：ストレステスト

どういう風に分担・連携するかを定義するのがソフトウェア開発手法
ウォーターフォール：アップフロント。
アジャイル：期限が迫ってくるなどするまで、タスクを何度も循環させる。

アップフロントアーキテクチャ（ウォーターフォール）
複数のフェーズを順番に実行して、最後にリリースする。事前に要求される設計作業が多い割に、後から変動する要素もあるのでうまくいかない。

エマージングアーキテクチャ
ソフトウェアを少しずつ構築する。
設計、コーディング、テストが繰り返される。

アジャイルプロセス
エマージングアーキテクチャを開発プロセスとして体系化。
最初から決まっている要件は少ない。
イテレーションの最中にも要件は変わりうる。
イテレーションごとに開発する部分を顧客と折衝する。
イテレーションは大抵2週間ごと。
具体的な手法のひとつはエクストリームプログラミングと定義されている。
スクラムも手法の一つ。

ディシプリンドアジャイル手法
予備的な分析を行ってから従来のアジャイル開発手法を開始するプロセス。

## アーキテクト

アーキテクチャは変更が困難な決断からなる。
アーキテクチャの設計は要件の分析に基づく。
分析結果：システムに期待される動作
アーキテクチャ：どのように期待される動作を実現するか
アーキテクトは要件と仕様を結びつける専門家

アナリストやプロジェクトマネージャーと情報交換し、システムの選択肢を評価及び提案し、開発者チームを調整する。
要件の承認、システムのサブシステムへの分解、テクノロジの特定と評価、仕様の策定がアーキテクトの責務。

予算割り当て。
アナリストが要件を洗い出し。（業務内容、業務プロセス、コンテキスト、エンドユーザーからのフィードバック。）
アーキテクトが要件を承認し、設計に組み込まれ、実現される。

プロジェクトマネージャーとアーキテクトは兼任であることもある。

システムの分解
要件に基づき、小さなサブシステムとプロセス内で動作するコンポーネントの組み合わせとしてシステム全体を表現する
論理的なレイヤーとサービスを思い描く。
コンテキストに基づき、各レイヤーのインターフェース、他のレイヤーとの関係、システムが要求するサービス指向のレベルを決定する。

レイヤリング→機能の垂直分布。
パーティショニング→全てのパーツが同じ論理レベル。サービス指向、ヘキサゴナルアーキテクチャとか。

全体的な設計は企業の目標に一致する。
ガイドライン。
コンポーネント間の結びつきを最小限に抑える
コンポーネント内の凝集性をできるだけ高める
コンポーネントの役割を明確にする

結果として得られるアーキテクチャは非機能要件に左右される

レイヤーを設計したら、論理的なコンポーネントを製品やテクノロジに割り当てる。？？？？？
製品やテクノロジのうち有益で費用対効果の高いものを提案する。

技術的な内容の最終的な決断はプロジェクトマネージャー下す。
提案が却下された場合、テクノロジを使用するかどうかは新たに満たすべき非機能要件となる。

アーキテクトはシステム開発の最終的な責任者。開発者チームの作業を調整する。
仕様書はアーキテクチャに関する決定事項をアーキテクトが開発者に伝えるための手段。
開発手法によってコミュニケーションの仕方も変わる。

エンタープライズアーキテクト
ビジネス戦略、編成、インフラストラクチャに充てている人。
ビジネスとITを結びつける。（ITコンサルとかに近いのかしらね。最上流。）
エンタープライズアーキテクト、インフラストラクチャアーキテクト、テクノロジスペシフィックアーキテクト、ソリューションアーキテクトなどの肩書きがある。
この人たちは基本的にソースコードにかかわらない。

リードデベロッパー
難しい決断をする立場にあり、アプローチやテクノロジの提案を任される役割。

ここでの定義はアーキテクトはコードに大きく関わる立場にある
アーキテクトはシステムを設計する
一方で正しく実装されるように開発者と緊密に協力する

アーキテクトはアナリストではない。
アナリストは特定のビジネス分野の専門家のことである。
システムに期待される動作やシステムが実行すべき機能についての所見をアーキテクトに伝えるのがアナリスト。

アーキテクトはプロジェクトマネージャーではない。
アーキテクトはシステムのアーキテクチャに対する責任を負う。
プロジェクトマネージャーは最初の段階で開発手法を選択することによりプロジェクトを管理する。予算の範囲内でスケジュール通りに進行させる。
別々のスキルが必要だけど両方やることもある。

アーキテクトは稼動環境ではコードを書かないかもしれないけど、コードを試したり、CTPやライブラリ、ツールのことを知っている。

アーキテクチャは必須
ソフトウェア開発では要件が絶え間なく変わるし、技術もころころ変わる。
従来の工学と比べて、計画通りに進まないことが多い。

# 第２章　成功のための設計

ビジネスニーズをよく理解し、ソリューションを引き出すプロジェクト。
うまくいく設計は既存のコードとインフラストラクチャを再利用した上で設計され、利用可能なテクノロジと既知のベストプラクティスを踏まえて改良されたソフトウェア。

品質が悪いソフトウェアはビジネスに影響を与える。
レスポンスが遅かったらトラフィックが離れる。
UIが使いづらくサービス待ち行列が増える。
処理されない例外が想定外の挙動につながる。

ソフトウェアディザスタ
大きくなりすぎて修正困難なシステム

大きくなる原因
・顧客の要求を網羅できていない
　コミュニケーションロス（言葉の取り違い、精度の違い、想定する実現難易度の違い）。十分な説明や代替案なく要求の取り下げを行う。
・システムを拡張するときにRAD（予め用意されたテンプレートの使い回しによる開発。rails gみたいな）を使っている
・見積もりの甘さ
　要件を精査せずに見積もりを立てる。
・テストが適切なタイミングで行われない
・プロジェクトの責任の所在が明らかではない
・問題から目を背ける

BBMの兆候
・デグレしやすい
・再利用性が低い
・修正しづらい

検知の仕方
・静的コード解析
・知識のサイロ（人に知識が依存している）


ソフトウェアプロジェクトの力学
組織
リーダーとボス
チームとプレイヤー
スクラムの火消し

チームのコードの品質を高めるには
レビュー
チェック

レガシーコード
改善中は新規開発を止める
傷んでいる部分を切り離す

# 第３章　ソフトウェアの設計原則

保守性は、リグレッションや新しい問題を生み出さずに、コードベースを更新に対処させる度合いを表します。
残念ながら、保守性は1回だけ実装すればよい機能ではなく、原則や一般的なパターンを採用したり、コードの明確さ、読みやすさ、テスト容易性に配慮するなど、さまざまな要因の結果です。

設計はあらかじめ行う必要があるが、コーディングと同時に行うものである。
コーディング中に新たな事実が判明するから。
判明した時点でリファクタリングを行い、且つバグが発生しないようにする必要がある。

## 観点

凝集性：クラス内メンバ同士の関連度。高い方が望ましい。クラスに割り当てられる定義に反比例する
結合度：異なるモジュール間の（実装への）依存の度合い。低い方が望ましい。

## 関心の分離

publicなインターフェースを公開し、それ以外を隠蔽する。これが本当のカプセル化。

## オブジェクト指向設計

関連のあるオブジェクト？を見つけ出す
相互にやり取りをするオブジェクトの結合度を減らす
コードを再利用する
（YAGNIの原則はもっともだが、ある程度将来の問題を解決するための汎用性も持たせるべき）

ドメインモデルパターンを利用したビジネスロジッククラスでは階層化を利用することがあるが、他の部分ではあまり階層化や継承を使う必要はないことが多い。

関連のあるクラス
ユースケースから名詞と動詞を洗い出す。
データを取得する振る舞いをどこに配置するかが問題。

インターフェースに対するプログラミング
横断的関心事は特定のユースケースに紐づくものではない。なので横断的関心事に依存することは避けた方がよい。
ServiceLocator、DependencyInjectionを使うべき。

クラスの継承と合成
継承によって実装を再利用できる。
基底クラスの実装が変わった時に派生クラスが正常に動作しなくなる可能性がある。同じコンテキストで使用されることが望まれる。リスコフの置換原則。
クラスの合成（委譲）により実装を再利用することも可能。
もし継承のように基底クラスと派生クラスを一緒に扱いたいなら、インターフェースを使うのがよい。

オブジェクト指向により必要以上に複雑になることがある。
変化する可能性が低い部分と高い部分を分ける。
クラスが必要でない場合は関数を定義するだけでよい。
現実の世界がモデルではなくイベントを表すことに注意する。

## 開発ベクトルと設計ベクトル

今まで説明したものは結構昔のものが多い。最近は拡張されたものもある。

SOLIDの原則
SIP：クラスを変更する理由は一つであるべき。クラスの責務を最小限に止める。
OCP：既存のコードを変更しなくても拡張可能。
LSP：サブクラスを基底クラスと置き換えることができなければならない。
DIP：DependencyInjectionやServiceLocatorなどが実装。上位のモジュールが下位のモジュールに依存してはらなない。

ServiceLocatorは特定のクラスの静的なファクトリメソッドでインスタンス生成を行う。
どのクラスもServiceLocatorに依存してしまう。
DI（IoC）コンテナは外部から依存性を注入するので、クラス自体がコンテナに依存することはない。
注入方法は、コンストラクタ、フィールド、アクセッサ。

## コーディングベクトル

DRY、KISS、YAGNI

KISS：単純に保つ。
YAGNI：今必要以上の機能を実装しない。でも汎用性はある程度担保した方がよい。
DRY：同じことを何回も繰り返さない・
Tell Dont Ask：使う側で事前に状態を確認しない。とにかく実行する。結果は戻り値で受け取る。

デザインパターン
役立つけど、万能ではない。無理に適合させる必要はない。

リファクタリング
外部から見た振る舞いを変えずに内部の構造を修正する。
メソッドの抽出
インターフェースの抽出
フィールドのカプセル化

防御的プログラミング
予想外の入力に対しても想定された動作をするようにする。
例外をスローする。
契約によるプログラミング
事前条件：入力値（メソッドのパラメータとインスタンスの状態）の検証
事後条件：戻り値の検証
不変条件：外部からインスタンスの状態が書き換えられたときの内部状態の整合性の検証

# 第４章　高品質なソフトウェアの作成

技術的負債
→★品質との関係は何？


技術的負債の原因（第２章参照）
→もっとも一般的なもの（第２章参照）：納期、早すぎる締め切り、要件への理解不足
→他にも：技術力不足、協力体制（★どことどこ？）、非効率的なスケージューリングなど。

Manny Lehman教授の理論「開発中のソフトウェアは複雑になるにつれ劣化する」
ソフトウェアが使用されている間、継続的に保守をする必要がある。（★繋がりがわからん）
良いソフトウェアとは、リファクタリングに適したソフトウェア

リファクタリングの効果
→テスト容易性、拡張性、読みやすさの三要素と、テスト結果

## テストしやすいコードの記述

リグレッションテストには、自動テストが効果的である。
RADパラダイム（Rapid Application Development？）
自動テストの書きやすさという観点が重要になった。

テスト容易性はコードのテストがしやすいかどうか。
コードのテストは、エラーがあるか、要件に適合するかを検査するプロセス。

良いコードの条件にテストできるかできないかという基準がある（★なぜ？ISOの品質特性の保守性の項目に検査性という項目があった。）
テスト可能なコードは、SOLIDの原則が適用されていて、他のモジュールとの結合度が低いコード。

---

理屈上、テストをしないと第三者に説明できないから必要。
内部の人がレビューするのはテスト以前の問題。
納品するときに発注者は単体テストレベルのテスト結果まで見るかというと現実的には見ないことが多い。
機能レベルでのテスト（登録と参照とか）は必要。お客さんが見るから。
これに関わるユニットテストは、機能レベルでのテストが通っているのであれば究極的には不要。
開発者が内部的にクラスレベルの役割を全うできているかをチェックする。

例えばメソッドAに依存しているメソッドBの出力が間違っていたとする。
メソッドAを直してもメソッドBも直しても良いが、メソッドCもメソッドA

単体テストをするというのは、仕様を固めるっていう意味もある。


ビヘイビア開発とテスト駆動開発
テスト駆動開発の中にビヘイビア駆動開発がある。
テストコードで仕様を記述しつつ、小さく製品コードを実装していく。それを繰り返していく。

そんなに仕様を意識しない場面もあるかもしれないが、「実践者が無意識的に意識している」だけ。

「もしこういう条件だったら、出力はこうです」

特徴1. テストケースを自然言語に近い記述で行う。
特徴2. 連続したストーリーのテストを行う。
メリット1. 結合テスト・ユーザー寄り受け入れテストを記述できる。
メリット2. 汎用性が高いため、状況に合わせて広く利用できる。

E2Eテストでは専用ツールが必要。（画面上でのテストには専用のツールが必要だから）

ユニットテスト

---


Design for Testability

■制御

テスト対象のソフトウェアに固定の入力データを適用できる度合い。
引数と戻り値の仕様が明確。
依存関係を注入できる手段がある。

■可視性

ソフトウェアの現在の状態と出力を確認できる。
メソッド実行後に検証される事後条件。

■単純さ

凝集性の高い単純なコンポーネント。


ソフトウェアテスト

単体テスト：単体
統合テスト：環境やインフラストラクチャに適合するか、複数のコンポーネントが連動するか
受け入れテスト：顧客の要件を満たしているかどうか

単体テスト
ユニットテストは開発者が自分のために作成するテストです。ソフトウェアの品質をチームが確認できるようにする。

依存関係
テストが失敗する理由が、テストするモジュールの不具合だけになるようにする。
DIで依存している依存性を注入する。

依存は以下の場合
クラスAがクラスBから派生している
クラスAにクラスBのメンバーが含まれている
クラスAのメソッドの一つがクラスBのメソッドを呼び出す
クラスAのメソッドの一つがクラスBのパラメータを受け取る
クラスBに依存しているクラスにクラスAが依存している

こういう時はクラスBのフェイクやモックを使う
フェイクは元のオブジェクトと同じインターフェースを提供するが、結果はハードコーディングされた値などを返す。
モックはオブジェクトのふりをする。フェイクオブジェクトと同じ。さらにメソッド呼び出しが行われたかなどをチェックできる。
モックに関しては専用のフレームワークを使う


統合テスト

1単位の機能についてのテストだけではカバーできない部分をテストする。
現実に近いシナリオでテストをする。
統合テストでは個々のコンポーネントのパフォーマンスと信頼性に関するテストを行う。
複数のレイヤーやティア、データベース、サービスをテストする。

単体テストよりも時間がかかる（手動でも自動でも）
全てのコンポーネントを結合すると時間が短縮できるけど、原因の切り分けができない。

モジュールがリリースされるまで結合テストできない。開始時期がかなり遅れる危険がある。
ボトムアップで行うほうが効果的。（★ボトムアップとは？）
早い段階で低レベルのモジュールを結合してテストをするのが効果的。
例えば固定値を返却する実装の状態で結合するのもあり。


---

ビックバンテスト

テストをしてそれっきりならビックバンテストだけでいい。けどそれが全体の工程を短縮することはあんまりない。


ボトムアップ

他のモジュールの完成品を待っているとテストが遅れてしまうので、モックをやっていると楽だよ。
シミュレータ。決済プロバイダとか。DBアクセスする部分をDBなしでもシミュレートする。
テストはデバッグツールに近い。

単体テストはクラスやメソッドみたいな小さい粒度のテストをやる。
機能テスト（結合テスト）はAPIエンドポイントの粒度でDBに登録されているかどうかをテストをする。
受け入れテストは画面でテストをする。（自動化するのであれば別の道具仕立てが必要）

1つのクラス: 単体テスト？
1つのデプロイ単位の中の複数クラス：結合テスト？
複数のデプロイ単位にまたがる動きを抑えるテスト（隣のAPIとか、RDBMSとかをモックにする）：統合テスト？

単体とか結合とかは相対的な言い方として捉えた方がいい。

SIer的にも用語はバラバラ。

- 単体テスト
- 結合テスト
- 統合テスト
- 総合テスト
- 機能確認テスト
- システムテスト

---

受け入れテスト

完成したシステムが要件を満たしているかを判定するために実行される契約テスト。
XPから取り入れられたもの？
ステークホルダーとQAが協力して受け入れテストを作成し、ユーザーストーリーをもとにテストに関連するシナリオを選択する。
ユーザーストーリーに応じて複数のテストで構成される。
肯定的なシナリオ（正常ケース？）をステークホルダーが担当し、エッジケース（異常ケース）をQAスタッフが担当する。
開発者がテストをレビューして、アクションが意味をなすことを確認する。
受け入れテストはブラックボックステスト。
リリース時の回帰テストとしての役割も果たす。互換性を損なう変更。

受け入れテストは設定されたシステムに対して実行されるステップバイステップ形式の指示の集まり。（つまり画面の操作の集まりということ？）
頻繁に行うなら自動化したほうがいいのかもしれない。

受け入れテストが実装上の噛み合うようにするには？（★必要性がわからない）
ビヘイビア開発を使うとできる？

ビヘイビア開発
★目的は最終製品のリリースに向けてステークホルダーの間で繰り返されるやりとりを定義すること？？？？
やりとりから明確に定義された出力を生成すること。
最初は高水準の言語を使ったステートメントに取り組むことが提案される。★DSL？？？？
その後ステートメントがコードになる。

---

理論上、仕様を決めれば受け入れテストをすることも可能である。
TDDでいうところの「コードを書く前にテストを書く」っていうのはE2Eも適用できる。

---

BDDのステートメントは事前条件、アクション、出力の3つを中心に構成される。

### TDD

TDDの目的はテストではなく設計。

ソフトウェア開発プロセスの一つ。
テストはその場での動作確認ではなく、リグレッションを検出するのが目的。

カバー率が低いとテストの正当性が怪しいが、高いからといって正当性があるとは言えない。
テストの仕様と実装に依存する。

どの部分をテストするべきか
ドメイン層をテストするべき。
ドメイン層はアプリケーションのロジックを左右する重要な決断が下される場所。
ドメイン層の次は、アプリケーションサービスとレスポンスの生成。

拡張性とオーバーエンジニアリング
拡張性はある程度必要だが、オーバーエンジニアリングになってはならない。	

インターフェースに基づく設計
拡張可能なクラスはインターフェースを定義しておく。現実的に全てを拡張可能にするのは難しい。
必要か不要かを判断する必要がある。

プラグインアーキテクチャ
マーチンファウラーのPluginパターン。

ステートマシン


コードの読みやすさは保守性という品質に関わる。コストにも関わる。
読みやすさはコメント、整合性、明確さで定義される。
公開するコードについてはJavaDocのようなコメントは必須。わかりきったコメントを追加しないようにすることも必要。
整合性はコードがプロダクト内で一貫してガイドラインなどに従っていること。
明確さ。IFかSwitchかなども一例。

また、一般的に短いほうが読みやすい。30行程度でメソッドに抽出したほうがよい。

# 第５章　ドメインアーキテクチャの発見

物事を行うこと
物事を正しく行うこと。

ソフトウェア開発には、プロトタイプを作ってビジネスに組み込むフェーズと、ソフトウェアの安定化を行うフェーズがある。

ソフトウェアアーキテクトはトップレベルのアーキテクチャという固定された枠の中でソリューションを考える傾向にある。全ての場所でこれを使用するのは間違っている。（★なぜ間違っている？）

---

コンテキストごとに別々のアーキテクチャを適用した方がいいことはある。
シングルサインオンとかもあるし。
開発者が10人いて、その中でRails2人にマスタメンテをひたすらお願い、Spring5人お願い、SSOを誰か1人。
こういう判断をアーキテクトがする。

---

ソフトウェアは現実世界を正確に映し出すことが期待される。ソフトウェアが現実の世界のどの部分モデリングしているのかを理解する必要がある。
その部分はビジネスドメインであり、理想的なアーキテクチャを必要とする複数のビジネスコンテキストを含んでいるかもしれません。

## DDDの本当の付加価値

DDDの目的はソフトウェアの核心にある複雑さに立ち向かうこと。

DDDを正しく行なったっ時のみ、強い力を発揮する。

でも間違えたやり方を実践しやすい。

DDDは特定のビジネスドメインに関する知識を咀嚼し、それを忠実に繁栄したソフトウェアを作るためのもの。

ビジネスドメインは、組織、プロセス、実務、人々、言語に関連している。
コンテキストの中にビジネスドメインがある。
DDDを効果的に利用できるのは十分な知識を理解し、ビジネスドメインに適したモデルに変えることができなければ、十分な結果は得られない。

DDDには分析と戦略という2つの部分がある。
分析は、トップレベルアーキテクチャを境界づけられたコンテキストで表現する方法を定める。
戦略は教会づけられたコンテキストをサポートするためのアーキテクチャの定義に関連している。

DDDの本当の付加価値はコンテキスト境界を定義するために分析部分を使用すること。
その後実装のために戦略部分が利用されることがある。

DDDを使った分析
ユビキタス言語と境界付けられたコンテキストという要素で構成されます。
ユビキタス言語はプロジェクトの関係者全員が使用する言語。理想的にはあらゆる形式のコミュニケーションで使われる。
ドメイン知識を深めながら動詞と名詞をユビキタス言語のリストに追加する。副詞句がイベントやプロセス、そのトリガーが見つかるかもしれない。
要件の改善、及び承認の迅速化に役立つ。関係者のコミュニケーション促進。誤解、前提の不備などを避けられる。
要件を理解してドメインを調査していくと、名詞と動詞が重複していたり、同じ言葉が別の意味で使われていることを発見する。

境界づけられたコンテキストはドメインのさまざまな領域のうち、独自のユビキタス言語を持つため別個に扱った方が効果的な領域を表す用語。ユビキタス言語が変化したら、境界づけられたコンテキストがある。ドメインからドメインコンテキストを洗い出し、論理的な輪郭を定義すること。

コンテキストマッピングはサブドメインごとの関係を明らかにし、戦略的な決断を下すのに役立つ。


戦略的なモデル設計
境界づけられたコンテキストを定義したら、それぞれに最適なアーキテクチャを決定する。
DDDではドメインモデルと階層型アーキテクチャの2つが推奨されている。

ドメインモデル
エンティティモデルと呼ばれる特殊なモデルと、一連のドメインサービスクラスで構成される。
ドメインモデルをドメインオブジェクトの集まりとして解釈する一方で、関数的に捉える動きもある。
タスクの実装などは実際に関数型プログラミングの方が望ましい場合もある（★どんな場合だろう？）

ドメインモデルを中心に設計した階層型アーキテクチャをDDDが提案する。
モデルがオブジェクトモデルでも関数の集まりでもなんでもよい。
永続化もモデルの構造に依存する。
モデルがオブジェクトの集まりである場合、ORMが必要かもしれない。
モデルが関数の場合、ストアドプロシージャがベースとなることもある（★よくわからん）

---

ドメインの役割があるデータならば、データを抽象的に表現したオブジェクトがドメインモデルの中核になる。
場合によっては変換することがドメインの場合もある。

RDBMSのデータだったらO/RMツール。
処理だったら処理をRDBMSにストアドプロシージャを作ろうという話な気がする。

今ならあまりストアドプロシージャを使わずに、Javaとかで処理したり、AWS Lambdaを使ったりする。

ここら辺の選択は、非機能要件とかメンバーのスキル次第だったりする。

---

DDDはオブジェクト指向設計の延長。（オブジェクト指向設計は３章を参考にする。）

戦略的なモデル設計。境界づけられたコンテキストごとにアーキテクチャを選択する。
階層型アーキテクチャの他にも、CRUD、CMS、イベントソーシングなどの選択肢がある。
選択の基準。

予想されるアプリケーションとデータの寿命が短ければ（数ヶ月）CRUDで問題ない。
それ以上ならもう少し考えた方がいい。

## ユビキタス言語

ユーザーと開発者が要件を共有するための共通言語。
特定のビジネスドメインの概念と技術的な概念を統一して拡張する。
とはいえ、ほとんどはビジネスドメインの語義を反映した言葉で構成される。

ユビキタス言語は要件の聞き取りを続ける中で練り直される。
原案は要件をアーキテクトが整理する中で見つけられる。

技術者はユビキタス言語が曖昧さがなく、一貫性があり、高度な概念や動作を表すために組み合わせることができる単純な要素であることを期待する。
ビジネスドメインの専門家は、用語や概念が未知である、ビジネスコンセプトを表現していない場合に却下する。

ユビキタス言語の抽出は最終的にUMLやWordなどを使って用語集としてまとめられる。
ユビキタス言語が変わったら、コードや規約にも反映する。

DDDの分析をした方がいいケース

1. 対処しなければならないドメインロジックが大量にある。それらを整理るすのが大変な時にユビキタス言語は重宝する。
2. ビジネス立ち上げ期で、ソフトウェアが作業の一部でしかなく、ビジネスロジックが明確ではない場合、DDDの分析によって明確になることがある。

## 境界づけられたコンテキスト

同じ用語の意味が人によって違っている
異なる要素が同じ意味で使用される

これはサブドメインの見えない境界を跨いでいる証拠。

問題空間のサブドメインがソリューション空間の境界づけられたコンテキストにマッピングされる。

ビジネスドメインを分割する際に、両方のビジネスドメインの共通部分がある場合がある。この時。共通部分をどのように扱うかを決定する必要がある。
既知の概念を表すのに別の言葉を使っていたり、一つの言葉に二つ目の意味があった場合などが該当する。
一つのモデルで複数の意味を網羅するのは危険。ごちゃごちゃする。

共通部分の扱い方
コンテキストを合体させてしまう。
共通のエンティティを共有カーネルとして扱う
共通のエンティティもそれぞれのコンテキストで別々に扱う

たいていの場合は、共通エンティティもそれぞれのコンテキストで別々に扱うのが良い。
共有カーネルでうまくいくのは、本当に同じエンティティを使う場合。

コンテキスト間の関係をコンテキストマップとして表す。
コンテキスト間の関係には、上流と下流があり、上流が変更されると下流も変更しなくてはならないことがある。逆はない。
コンテキスト間の関係は5つに分けられる。

腐敗防止層
順応者
顧客/供給者
パートナーシップ
共有カーネル

コンテキストマッピングはソリューションの戦略的設計の一部。
システムへの理解を深める上で大きな助けになる可能性がある。

腐敗防止層？？？
レガシーコードや外部システムを隠蔽している場合、腐敗防止層は有用。

コンテキストごとにアーキテクチャを定める。
よく使われるサポートアーキテクチャは以下の5つ。

- マルチレイヤーアーキテクチャ（プレゼン層、ビジネス層、DB層）
- マルチティアアーキテクチャ
- クライアントサーバーアーキテクチャ（二層）
- ドメインモデル（プレゼン、アプリケーション、ドメイン、インフラ）
- CQRS（コマンドとクエリを処理する並列セクションを持つ二重の階層アーキテクチャ。コマンドとクエリを別々に設計することが可能。
- イベントソーシング（イベントがファーストクラスのデータとして扱われる。クエリの結果はコマンドから推測。）
- モノリシックアーキテクチャ

## ドメインモデルの階層アーキテクチャ

プレゼンテーション層
ユーザーインターフェース。アプリケーション層に入力モデルを渡し、受け取ったビューモデルを表示する。
入力モデルとビューモデルは一致することが多い。

アプリケーション層
ビジネスロジックのオーケストレーションをする。
ユースケースの実装。
バックエンドへのインターフェース。

ドメイン層
ユースケースに限定されないビジネスロジック全体。
ドメインエンティティとドメインサービス。
ドメインサービスは複数のドメインエンティティを操作したり、インフラストラクチャ層へのアクセスをしたりする。

インフラストラクチャ層
技術的関心事。
永続化、セキュリティAPI★？、ろぐ、IoCコンテナ、キャッシュ

## まとめ

事前に設計しすぎても、コストだけかかってうまくいかないことがある。
ドメインへ理解を深めるのと、コードを書くのを同時並行にし始めた。（★この話あったっけ？）
動くソフトウェアも大事だし、よく設計されたソフトウェアも大事。
妥協点を探るにはドメインへの理解が必要。
ドメインを理解することで適切なアーキテクチャの発見につながる。
ドメインとサブドメインの関係は分割統治。

# 第６章　プレゼンテーション

バックエンドとフロントエンドは同じくらい大事。
デバイスごとにユースケースが変わる場合もある。例えば画面サイズの都合とか。

最初にプレゼンテーション層で必要となるシナリオや振る舞いを理解しておくことが、ドメインの分析にも役立つ。
UXファースト。
GUIのやりとり（画面や帳票？）に着目する。

タスクとタスクの入出力に注目する。

バックエンドのエンティティじゃなくて、ユーザーのやりとりを元に考える。
画面ごとのビューモデル。承認・定義される単位が画面ごとだから合理的かもしれない。
ビューモデルはDTO

★ビューモデルはDAOパターンでいいって言われているところにもつながる？
★計算ってどこに持たせるの？ビューモデルってドメインオブジェクトの集合？それともビューモデルの中身がプリミティブになるようにするの？

---

ECの画面で商品一覧を出している。
商品一覧だけじゃなくて、ログイン情報とか購入履歴だけが表示されていることが多い。

ビューモデルという時は、画面に表示されている情報全てひっくるめて指す。
読み込み・クエリモデルは別。

未解決問題。
ある種の計算はドメイン知識なのでドメインレイヤーにおきたいと思えるものがあるが、使いたい場面がフロントエンドでもある。

1. JavaScriptを使う。
2. サーバーサイドのテンプレートエンジンを使う

どっちにしてもプレゼンテーション層。ここでドメイン層のロジックを呼び出してしまっていいのか。
実際にMONOPOSではサーバーサイドとクライアントサイドの両方で実装している。

クライアントサイドで実装しないとしたら、サーバーサイドAPIを毎回呼び出す必要が出てくる。

出荷情報の連携。
倉庫システム。入出荷のシステム。ウェアハウスマネジメントシステム（WMS）。と出荷システムの情報を連携する。
CSVファイルを作るときに1個1個の項目はValueObject的なものであって欲しい。
でも連携部。
CSVファイルはWMSによって変わる。これは画面ごとに表示がちょっとずつ違う。

外部インターフェースの最前線で値オブジェクトを呼び出してしまってよいのか。。。

本にするならこういう話もできたらいいな。

---

UXの4本の柱

1. 情報アーキテクチャ
2. インタラクションデザイン
3. ビジュアルデザイン
4. ユーザビリティのレビュー

ユーザーから情報を予め吸い上げることもできるが、実際に使ってもらってレビューをもらう方が遥かに重要。

効果的なUXのアプリケーションを作るには

1. UXを視覚化する。ユーザーの対話モデルがどんなものかを示す。（スケッチ、ワイヤーフレーム、モックアップ）	
2. プロトタイプを作成して、ユーザーレビューをもらう
3. プロトタイプをもとにアプリケーションを開発する

★対話モデルって何？

プレゼンテーションの2つの要素
UI：インターフェースに必要な情報を表示する。
プレゼンテーションロジック：ユーザーのアクションをバックエンドシステムへのコマンドに変換する。MCVではController。WebではHTTPリクエストやセッションをもとにアプリケーションへのコマンドを構築し、レスポンスをHTTPのレスポンスとして返却する。

アプリケーションサービスでユースケースを実現する。

モバイルとレスポンシブ対応
ウェアラブルデバイスもある。
要素の表示・非表示などをデバイスごとに変更するだけなので、不要なコンテンツのダウンロードを強制したり、デバイスによって帯域幅が変わることなく画像がダウンロードされる。
★帯域幅？	
デバイスによって最適なユースケースを実装したりできない。
JavaScriptでデバイスごとの最適なCSSをダウンロードすることもできるが、デバイスを識別する方法が難しい。
★WUREF。
サーバー側ででの対応はデバイスを検出して、それにあったテンプレートをHTMLとして返却する。
クライアントサイドでの対応はデバイスを検知して、デバイス専用のHTML要素を挿入する。

---

どのデバイスがどんなシチュエーションで使用されるか。
パソコンは座って落ちついて見える。全部の情報を見せる。
モバイルだと表示幅もそうだけどサマリーとかをパッと見られるようにする。

SPAだと。

商品一覧を出しますっていうときに、いくつの商品をを表示するかを画面幅によってパラメータで。
DOMのイメージタグのイメージファイルのパスを変える。（デバイスによって解像度）

---

SPA
サーバー側の処理量の一部をクライアントサイドが負担する。
基本的にビジネスロジックはサーバーサイドで持たせるが、クライアントとサーバーでどれぐらいのロジックを持つのかは場合による。
いずれにせよ、プレゼンテーションロジックの組み合わせと単一サーバーコマンドの呼び出しぐらいに留めておいた方がいい。
コマンド呼び出しを組み合わせた瞬間、それはサーバーの責務を奪っていることになる。

SPAを採用するときはいくつか気をつけた方がいい。

- 新しいユーザーインターフェースになれる必要がある。（ステートレスからステートフルへ？）
- モバイルで正しく動作するとは限らない

---

SPAがモバイルで動かないとかは今はあんまりない。
メモリの制限？

---


デスクトップアプリケーション
SPAとあんまり変わらない。

リッチWebクライアント
古いWebとのバランス。
新しいWeb→戻るボタンがきかない。ディープリンクがない。

ネイティブモバイルアプリ
デスクトップアプリケーションとほとんど同じ


# 第７章 伝説のビジネス層

ビジネスロジック＝ビジネス固有のコアロジック
システム全体のアーキテクチャに依らず同じもの。

現実のビジネスプロセスをモデルとするアプリケーションでは極めて複雑なロジックを扱うことになる。
CRUDのような単純なアプリケーションでは単純なActive Recordパターンなどが有効。
だけどそうでないような複雑なものもあるので区別して考えるべき、

トランザクションスクリプト
ユーザーアクションにビジネストランザクションを割り当てる。
構造化されていない。
ビジネスロジックをタスクベースで考える。
CRUDなど単純なもので有効。
runメソッドをもつCommandクラスみたいな感じ？

ドメインモデルパターン
システムの振る舞いとデータの流れに注目する
ドメインモデルはビジネスドメインとそのプロセスとデータフローを再現するモデル。
複雑で変化しやすく拡張性が求められるような部分に有効。
ドメインモデルはビジネスに対するAPI。間違った使い方をされないようにする必要があるのとできる限り使い方の制限をしないことが重要。
アクションやイベントに注目してドメインモデルを定義する。

---

トランザクションスクリプト
SpringのControllerに全部ロジック書くとする。Controllerがデータベースアクセスも全部やる。

ドメインモデル
Controllerからデータベースを直接呼ばない。別のJavaAPIを通してデータベースにアクセスする。

※Controllerのメソッドはどちらにせよタスク。

タスクベースUIとオブジェクト指向UI
タスクベースは操作を選んでから操作対象のオブジェクトを選択する

オブジェクト指向UIはオブジェクトを選んでから操作をする。

グレッグさんの考えているタスクベースっていうのはCQRSのコマンドの方を指している。
上野さんのタスクベース。

最終的にやるデータ処理の振る舞いだけを作り込んじゃうのがタスクベース、トランザクションスクリプト

どういう情報セットがあって、どういう振る舞いがあるのかをユースケースから分析して、それを操作するというのがオブジェクト指向UI。

タスクかどうかは一旦置いておく。
エンティティっていう階層をおくかどうか。

画面とデータベースのテーブルが1対1。

ドメインオブジェクトという内部インターフェースを挟む。
Javaでできているなんらかのモジュール分けを内部インターフェース。JavaAPIとか。
外部インターフェースはプロセス（物理）間のインターフェース。
トランザクションスクリプトは内部インターフェースがない。

トランザクションスクリプトの方がCQRSに近いのでは？
コマンドとクエリとでそれぞれスクリプトがあって、共有しないので最初だけバラバラ。

コマンド側（注文に対する話でいうと）も個数を変更する。明細を一部取り消す。引き当てしたので完了にする。出荷する。
マスタメンテじゃなくても更新で色んなユースケースがある場合は。
ドメインオブジェクトに生えているイベント・メソッドがコマンド。
「取り消し」って言われた時にどういう
「注文（集約）」のライフサイクルはどんなものがあるのか。今実装するユースケースに限らず、どうなるのか。

イベントソーシングとCQRSは別物。
一貫性に対しての要求度やパフォーマンスに対する要求度がめちゃくちゃ高くない限りはES+CQRSを使わなくてもいい。

CQRSは単にコマンド用のモデルとクエリ用のモデルを分けようというだけで、コマンドを保存するとかいう話とは別です。

---

ドメインモデルはリレーショナルモデルとは別物。
変換する必要がある。
ORMライブラリの仕様により、ドメインモデルに対して妥協する部分が出てくる。デフォルトコンストラクタを定義することなど。

責務駆動設計
アプリケーション層はタスクのオーケストレーションを行う
アプリケーション層とプレゼンテーション層の接合点がController
アプリケーション層とインフラストラクチャ層の接合点がRepository

ドメイン内でのタスクのオーケストレーションはドメインサービスと呼ばれる。
複数のエンティティに跨ったビジネスロジックを管理する。

入力モデル、ビューモデル、ドメインモデル、データモデルの変換。
ドメインモデルだけでビューモデルを表現しようとすると、循環参照が発生するなど複雑になるので、専用のビューモデルを別途作った方がよい。
変換は面倒なので、何かしらメタプログラミングやツールで自動化をした方がいい。（c.f. AutoMapper）

---

ここら辺の話はできたらいいような気がする。


ちょっとしたローカルな項目導出があることがあるので値オブジェクトはシェアしたいことがあるかもしれない。
住所っていう４項目ぐらいのオブジェクトがある。郵便番号、都道府県、住所、宛名。
2021年。

注文データに商品マスタの情報を埋め込むべき。
業務の必要性上、困る。
トランザクションデータには参照したマスタの情報を保存する。金額はマストで保存する。
分析に用いるカテゴリ、経理的に使う分別するための属性も保存する必要がある。

明細単位の小計。単価と個数と消費税を持っている。参照系でも欲しいかもしれない。
小計。テーブルは帳票。ユーザーインターフェース。
埋める時は参照するときミスすることはあんまりない。
更新時に計算する時は何かの加減で書き変わっちゃうリスクがある。→これは導出項目に限ったことではないのでは。
更新処理の実行時間が長くなる。
参照側に寄せるか更新側に寄せるかどっちに寄せるか。
バグを埋め込んでしまう可能性があるので、アプリケーションの中では統一した方が良い。

イベントソーシング的には更新側は導出項目を保存しなくても、裏側で参照側のモデルに導出項目を埋め込んで移管してくれる。

---


# 第８章 ドメインモデル

昔は要件分析、エンティティとプロセスの洗い出し、データモデルを推測って流れだった。
昔はテーブルに対してビジネスロジックをストアドプロシージャとして実装していた。
ドメインモデルはプリミティブなデータ型を滅多に使わないし、コンストラクタよりファクトリメソッドでオブジェクトを構築したりする。
ドメインモデルと永続化モデルは別物として考えた方がいい。

同じ物に対しても、コンテキストによってモデルは変わる。（地図の図法みたいに）

DDDは分析部分は誰にとっても効果的。ドメインモデルパターンを使って実装するかは別問題。

データベースはインフラストラクチャである。データモデルの文脈では重要だけど、ドメインモデルにとっては重要ではない。
逆にアプリケーションは永続化に配慮するべきである。

ドメイン層はドメインモデルとモジュールとドメインサービスがある
モジュールは名前空間のこと。
ドメインモデルはユビキタス言語の実装である値オブジェクトとエンティティで実装される。値オブジェクトはイミュータブル。値によって同一性が定義される。エンティティは属性によってではなくIDによって同一性が定義される。エンティティはデータと振る舞いをもつ。

永続化の対象となるのはエンティティのうち集約と呼ばれる物。いつも同時に参照されるエンティティが一つのエンティティにまとめられたようなもの。
厳密には整合性の境界で、ビジネストランザクションと結びついている。データを変更する目的で一つの単位として扱われる。
ビジネスの不変条件をもとに集約を特定する。
集約内にはトランザクション整合性が存在する。集約外には結果整合性が担保される。

---

アトミックトランザクション
BEGIN;COMMIT;する処理をどうにかしないといけない。

アトミックトランザクションをどのように分割するかという観点の一つが集約やトランザクションスクリプト。

不変条件（いつ何時でも満たしていないといけないもの）
（小）Orderのヘッダと明細があったとする。明細の個数と単価を変更してもいいけどもNullであってはいけない。小計は単価と個数の積じゃないといけない。ヘッダの合計は小計の合計と一致しなければならない。これが不変条件。注文明細から参照されている商品を削除しちゃいけないっていう不変条件を鵜呑みにして集約内に商品を入れるのはいけない。ライフサイクルとかも関わるので。
（大）集約をまたいだとしても集約またぎの不変条件はあるんじゃないの？ということ。

関連の中でuse aなのかhas aなのかで集約の境界を判断できるかもしれない。

結果整合は遅延するものの最終的には必ず整合性がとれることを。

一般的にはキューを置いて。
リソースA
リソースB
リソースC

リソースAが終わったイベントが発生したら、リソースB。

どれぐらいの遅延が許されるか。
1時間、1日とかだったら業務要件上、でているはず？

注文を受けて出荷指示がない状態があり得るかどうか。
注文を受けたけど決済を受けていない状態があり得るかどうか。
注文を受けたこととメールが通知されることがあり得るかどうか。
「すぐに」と言っても数秒ぐらいなら遅れても構わない。
性能要件、性能要件を満たすためのコスト。

1人の利用者の視点だと、注文〜通知までの時間が短ければ短いほどよい。
サイト全体の観点では、同期的に行う処理を

注文〜通知に関して
スループット→単位時間あたりに注文〜通知
レイテンシ→注文〜通知までの時間

トレードオフになる場合もある。
基盤の性能の問題もあるけど、同期的にやるのかによって変わる。
スループットをよくしたいなら、最低限の処理を同期的に行って、すぐにリクエストの口を開けるようにする。
エラー処理を考えないといけないことは増える。
同期処理ならその場でエラーメッセージを出せばいいけど、非同期なら通知？リトライ？

非同期するってアイデアに気付けるかどうか。
経験者から事例を聞く。（直接聞く。記事を読む。本を読む。講習会で勉強する。）

本田技研
和光市
生産管理システム。

古きよき日本の会社。先輩後輩。ちゃんとした組織の先輩後輩のピラミッドができていて、技術の伝承ができているんだなって思っていた。
代々先輩から引き継がれているみたいなことがない限り厳しいんじゃないかと。
先輩から教わって覚えてきたものが多いのでよかったなと思ったんですけど、上の世代から教えてもらうみたいなのがない。
上の世代も要素技術が変わっちゃって伝えることなんてないんじゃない？下の世代も要素技術が変わっちゃっていて聞く意味ないんじゃない？って思っちゃったりしている。

外の世界とのギャップとかお客さんとの違いとかがないと。
外部からのインプット。

---

集約内にはエンティティが2〜３階層程度ネストすることがある。


集約のメリットは、ドメインモデルとビジネスロジックの実装が容易になる点。オブジェクトの粒度が大きくなるから。
外部から処理するべきエンティティの数が減るから楽になるのかな？

集約間の関係は集約ルート間の関係として表す。
モデルの密結合を防ぐ

ドメインサービスは要件に定義されていてユビキタス言語に完全に含まれている。
集約やエンティティを跨いだ振る舞い、データベースアクセスが必要な振る舞いを定義する。
インターフェースにはアプリケーションから呼び出し可能な振る舞いとその契約を表す。

ドメインイベント
何らかのタスクが完了した時を表すオブジェクト。
「特定の出来事があったときに何かを行う」ような要件ではドメインイベントを利用する。
ドメインイベントを発生させる処理とハンドリングする処理が必要になる。

横断的関心事はインフラストラクチャ層に分類される。
バリデーション
エンティティは常に正常な状態を保つ必要がある。一方でUIやプレゼンテーション向けのバリデーションは別の実装が必要になる。

セキュリティ
認証認可の話と業務承認の話がある。

その他
ログやキャッシュ

# 第９章 ドメインモデルの実装

## はじめに

簡単な注文サイトを例に説明。
・ユーザー登録
・ログイン
・ニュースレターの購読
・注文検索
・注文作成

とても単純なので境界づけられたコンテキストは一つだけ。
実際はシナリオの複雑さ、ユースケースの数、期待されるパフォーマンス、その他の要件によってコンテキストの数は変わる。

## ユビキタス言語の抽出

ユースケースを分析してユビキタス言語を定義知る。

---

### 洗い出しの段階

色んな部門にヒアリングする。
色んな人に聞いてみて、どんな言葉が使われることが多いのか、似ている言葉としてどんな言葉が使われるのか知る。
例：登録ユーザー、顧客、カスタマー

### ユビキタス言語の抽出

ユビキタス言語を抽出を試行錯誤する。
最初に書いたユースケースを再度統一した用語を使ってみて、不自然がないかどうかをチェックしてみる。
最初はエンティティとか考えなくても良い。用語を統一することを考える。
動作の定義になることもあるし、名詞になることもあるし。

### （論理的な）境界付けられたコンテキスト

境界づけられたコンテキストをどう認識するかがポイント。
論理的な境界づけられたコンテキストはシステム化しようかしまいが変わらない。
コンテキスト同士は強く分断されているわけではないこともある。
コンテキストには大小があり包含関係にあるものもあると思う。

システム対象化範囲をとして見出したコンテキストの中からいくつかのコンテキストを選択する。
結果的に開発プロジェクトのスコープ、システム対象化範囲の内と外がコンテキストの境界として認識されることがある。

たとえ開発スコープに含まれないコンテキストだからと言って分析しなくていいという話にはならない。
注文サイトを含む5割増ししたぐらいの範囲を見てみて、周辺まで分析してみないと適切にコンテキストを分割できないこともある。

### コンテキスト同士の関連性

コンテキストは完全に分断されているわけではなくて連携がある。
どういうふうな連携があるのか、どっちがどっちに依存しているのか、疎なのか密なのかなどを分析する。

順応者とか共有カーネルどかは気にしなくていい。

### （物理的な）境界づけられたコンテキスト

論理的な境界づけられたコンテキストはソフトウェア実装前の段階でわかっている。
実際に物理的にデプロイ単位を分割するかどうかは別の問題。
開発リソースや仕様変更のライフサイクルなどをもとに物理的な分割を行うか考える。

---

自ずとエンティティを抽出することができる。
抽出したエンティティに対して期待される振る舞いを定義する。

## プロジェクト構成

ドメイン（バックエンド）
インフラストラクチャ（バックエンド）
サイト（フロントエンド）
  アプリケーション
  プレゼンテーション

ドメインとインフラストラクチャは同一コンテキスト内のフロントエンドから使用される。

## ビジネスドメインを境界づけられたコンテキストに分割する

このアプリケーションでは3つの境界づけられたコンテキストがあると考えられる。

- 認証・会員アカウント管理
- 注文
- 商品管理

これらをコンテキストマップにまとめる。
コンテキスト同士の関係性と、それぞれのコンテキストに当てはめるサポートアーキテクチャを定義する。

商品管理で行われた変更を注文で検知する方法はいくつかある。
直接商品のDBを見る、DBのAPIを叩くなどをして、更新された情報を直接見る場合。
もう一つはドメインイベントを受け取り、注文コンテキスト内の商品のデータを更新する場合。

BCに対して以下の戦略がある。

- 一つの大きなBCを使用する。
- ドメインを小さなBCに分割し、Pub/Subで連携する
- 大きなBCから特定の部分を切り離し、Webサービス化する。（商品のWebAPIを呼ぶなど。）

---

コンテキストが3つあるのは明白。ただし、それが境界づけられたコンテキストとなるかどうかはまた別問題。

論理的な関係性は変わっていないのに、BCに対する戦略がある。
開発リソースや仕様変更のサイクルの違いなどを考慮する。

物理的な境界は運用上の問題。

---

どんな選択肢がよいかは、ケースバイケース。

## 実用的なドメインモデルを作るには

コードよりもドメインモデルを考える。
その上で重要なことは3つ。

- 振る舞いを考える。
- 永続化のためにある程度の妥協は必要
- モデルはビジネスドメインのAPIで、フロントエンドなどで使用される。

データベースからモデルを推測することが今までは一般的だったが、そうするとドメイン貧血症になりやすい。
これを防ぐには以下のことを検討してみる。

---


### コンテキストにおけるワークフローを考える

前述の、「会員コンテキスト」「注文コンテキスト」「商品管理コンテキスト」には、それぞれ中心となるデータセット「会員」「注文」「商品」が存在する。

これらのデータセットをコンテキストの中心となる集約（エンティティ）として、集約の状態変化を整理する。一連の状態変化のことをワークフローと呼ぶ。（倉田的にはライフサイクルとかとも近いと感じた）

会員：登録→（変更｜凍結→凍結取り消し）→退会
注文：注文→（注文内容変更 | 注文取り消し）→注文受付確定→（注文取り消し）→出荷
商品：登録→販売開始→販売終了→削除

このワークフローを実現するためのメソッドを集約に定義される。ここで定義するメソッドは、一定の条件（引数やインスタンス内部の状態）を満たす限り、インスタンス内部の整合性を保ち続ける。これらのメソッドを除き、集約の内部状態を書き換えないようにする。インスタンス内部の整合性を保つためだ。

### コンテキストや集約の境界線

ワークフローに定義されているアクティビティについて、
「既存のデータセットを書き換えている」のか「新しい別のデータセット」なのか判断するのが難しい。

例えば、注文に対して出荷というアクティビティが存在するが、「出荷集約」が存在すると言う見方もできる。
出荷の場合は、注文のUPDATEと出荷のINSERTを実際には行うことが多いが、この判断基準はどこか。

コンテキストや集約の境界線は業務を見ないと分からない。
データを見ているだけでは分からない。

集約に定義するアクティビティの実行条件を左右するようなアクティビティは、その集約に定義した方が良い。
例えば「出荷」アクティビティを実行するには「注文確定」アクティビティが完了している必要がある。この時、「注文確定」アクティビティは「注文」集約に定義した方が良い。

あとは利用者が取り消しイベントを起こしたのかどうか。
注文訂正伝票（対象注文100番）を渡すような業務なのか、電話で変更できるようなものなのか。
注文訂正伝票が必要ならそれに対応する集約を定義する。

日次の売上計上処理を行ってからの注文変更。
売上のコンテキストでは会計締めというビジネルルールがあるから、注文と赤伝を別々の売上として処理する。
一方で注文のコンテキストにおいては最新の注文情報が知りたいので、注文集約の状態変更を行う。

（経験談）
注文と売上とデータの構造が大抵違う。ビジネスルールが違う。
データセットを分けて、注文から売上を作る方が作りやすい。
機能要件を満たすためにそれが必要だと考えていた。
自分で考えついたというよりも先輩が考えていてそうだよねと思った。

今のシステムでは注文と売上が分かれていない。
いろんなビューを作り出す。出荷指示、売上も。
だけど要件上問題ないが赤伝が表現できない。
会計システムに繋いでいるわけでもなく、小規模のクライアントが多い。営業的に売上が見られればいい。

### コンテキストを発見する

コンテキスト、ドメイン、集約、ワークフローの分割単位は全て表裏一体。
結局コンテキストを発見することが最重要課題。

関わるロールに対して１コンテキスト存在するのかもしれない。

（経験談）

営業が注文に注目している在庫と、経理が注文している売上の在庫は違う。
営業側は何部印刷したか、何部売れたのかが重要である。
一方で、図書のうち雑誌は資産にならないので、経理視点では雑誌の在庫はどうでもいい。

また図書の分類の仕方が、営業と経理によって違った。
大分類、中分類、小分類のうち、大分類と中分類をヒアリングした段階では営業と経理で共通だったので同じ概念として扱っていたが、小分類は営業と経理で異なった。

営業側のコンテキストと経理側のコンテキストが違っていて
その両方に取引区分っていう概念が存在してた。

---

- ある関数がエンティティを引数にとるとき、そのロジックはエンティティに属しているロジックではないか。
- 同一集約内の複数のオブジェクトを使用する場合は集約ルートに属しているロジックではないか。
- 永続化レイヤのメソッドを呼び出す場合、ドメインサービスに属しているロジックではないか。

エンティティとはIDによって識別されるクラスのこと。等価性を比較するメソッドを実装する必要がある。
書き換えられるプロパティは限られるため、基本的にセッターはプライベートにする。
代わりにコンストラクタで値をセットする。コンストラクタには名前がないので、ファクトリメソッドを採用してユビキタス言語を使用することもある。

値オブジェクトは値を表すクラス。値オブジェクトは不変の状態のみを持つ。
コンストラクタとパブリックゲッター、状態を書き換えないメソッドを持つ。
また状態によって識別される。演算子オーバーライド。
プリミティブ型は値の範囲が広すぎるけど、値オブジェクトを使用することで値の範囲を制限できる。
値オブジェクトは値の内部にある構造を隠蔽するためにも使用される。（住所の中身とか）

エンティティ同士の関係性をもとに集約を特定する。
顧客やユーザー周りは認証の仕様によって集約の捉え方が変わることがある。
集約の構築プロセスに複雑なビジネスロジックが絡む場合はドメインサービスを使う。
状態を書き換えるメソッドは単純なセッターとして定義するのではなく、ユビキタス言語を使うと分かりやすくなる。
また状態を書き換えるメソッドは戻り値がない場合が多い。インスタンス自身を返すとメソッドチェーンできる。
算出可能なプロパティもパフォーマンスが気になる場合はプロパティに定義して、リポジトリで予め計算をする。
SpecialCaseパターンによって例外処理を行うこともある。

永続化処理ではORMを使う。CRUD、クエリ、トランザクション、並行処理などが責務。

## ビジネスロジックの実装

全てのルールやタスクが一とつの集約に収まるわけではない。ドメインサービスを使用する。

単純な処理であればアプリケーションサービスを使用せずコントローラーからビジネスロジックを呼び出すことも可能だが、それは後から考えてリファクタリングすれば良い。

ある集約に対して何かのタスクを行った時に他の集約に対してタスクを行う場合、ドメインイベントを使うことがある。

# 第１０章 CQRSの紹介

DDDの分析部分で境界づけられたコンテキストを特定する。
コンテキストに対してサポートアーキテクチャを割り当てる。

ドメインモデルが一意なモデルだと考えられていた。

DDDの分析部分はどこにでも役に立つ。その先は適切なアーキテクチャを選定する。

---

必須は書き込みと読み込みが一緒じゃなくてもいい。
導出される問題としては、書き込みを読み込みに反映する必要があります。
同期的に作るか非同期にするかは決まっていない。

イベントソーシングは差分情報を書き込む。
ステートソーシングは結果を書き込む。

書き込みモデルと読み込みが同期的に同期する。
アトミックトランザクションの中でやっていてもいいですよ。

---

## コマンドとクエリを分離

全ての側面に対処するモデルを設計することが難しい。
クエリとコマンドが同じモデルを使用すると論理的な境界がぼやける。
読み取りと書き込みの分割統治。

CQRSでは2つのドメイン層を分割して使う。
クエリスタックではドメインモデルを使用せず単純な実装にする。
コマンド側はビジネスロジックを実装する。
従来のドメインモデルはクエリとコマンドの両方に対応する必要があるため、必要以上に複雑だった。

---

集約みたいな大きなビジネスロジックは参照側にはない。
小さいロジック（値オブジェクト的なもの）は参照系からも参照したい。

整合性チェックみたいなやつは参照側にはいらない。確かに。
値オブジェクト単体の整合性チェック。
注文のステータスがぺけぺけだったらエンティティ粒度のロジック。参照。
参照時にチェックされるべき整合性と更新時にチェックされるべき整合性がある。

クエリ自体に参照時に行いたい整合性チェックが入っていて。（LEFT JOINとINNER JOIN）
クエリ自体がドメインの表現。匙加減。

参照と更新で重複してロジックをもってもいいみたいな場合。
二重に管理するのは大変だから値オブジェクトとしてロジックを分割したいのか。
そもそも導出しない。

これは内容次第。

---


## 利点

CQRSを使うと設計を単純化することができる。

スケーラビリティを向上させることができる。読み取りと書き込みのいずれかに実行頻度が偏っている場合、チューニングができる。

---

CQRSのモチベーション

読み込み側と書き込み側で要求が違うので異なるドメインモデルを使う方が適切です。

読み込みトランザクションの方が多い。非正規化したデータを持ちたいとか。結果的にモチベ。

データモデルとは相反する考え方。
Shopifyとは別に独自に商品マスタデータベースを持っている。
ECの運用を始めたときにShopifyの商品マスタと独自のマスタが同じなのか。

Auroraのリードレプリカ。CQRS。
反映時間差。

JOINのパターンがたくさんあったとしたらJavaみたいなアプリだとJOINのパターンに応じてクラスを分けざるを得ない。
クエリ要件が１個しかなくても分けることが全然ある。
SELECTしてくりゃいいって言っているのは正規化データモデルを一式用意していればクエリでどうにでもなる。
SQLを書くだけではなく、データモデルを１個でいいといいいつつAPI
ソリューション

読み込みモデルとSELECT結果ですね。
要件に応じてリードモデルやクエリが一つずつある。
そもそもクエリの結果はない。

ロジックを使いますにはやっぱりレコードをアプリケーション上のインスタンスに変換して、計算させるのがよいのか？

サブジェクトとオブジェクト。
オブジェクト指向で神クラスができる。
サブジェクト指向。CQ。ReadとWriteで分けるみたいな概念がなかった。
同時に満たそうとするから神クラスになる。
要件ごとに部分クラスを作った方がいいんじゃないか。
アクターが個別の要件を持っていて。

DDD的にアプリケーションのレイヤーとドメインの間にサブジェクトというレイヤーがある。

アクターも階層的だしコンテキストも階層的。
アプリとデータの間にドメインっていうレイヤー。
この階層って要件によって変えた方がいいんじゃないの？
→

渡辺さんの視点ではアプリケーションとドメインを合わせてアプリケーションと言っている。
アプリケーションレイヤでは任意の階層をつけた方がよい場合もある。

DBを詳細。

更新要件と参照要件。
リレーショナルモデル自体の位置付けは帳簿。

RDBが帳簿
業務システムが帳簿だっていうところから抜け出さないと。

リレーショナルモデルとオブジェクトモデル。
RDBはユーザーインターフェース。

オブジェクトモデルから見るとプレゼンテーションもデータベースもUI。
プレゼンテーションはタスク。データベースは帳簿(経営者とか)。

---

影響範囲をクエリとコマンドそれぞれに分離することができる。

複数のアクターが同じリソースにアクセスをするような協調システムでは問題が発生する。
それは読み取られたデータが古くなっている可能性があること。

以下の対処が考えられる。

- 更新完了するまでの間集約をロックする。
- ロックしない。結果整合性。

リクエストはプロセッサのキューに追加されるコマンド。
コマンドに対して専用なハンドラがある。
コマンドハンドラはコマンドを一度実行する。
実行後イベントが生成され、他のコンポーネントによって処理する。
例えばクエリパイプライン専用のデータキャッシュを更新することなど。

クエリのデータキャッシュは画面に表示する（読み取りたい）データの形式をそのままテーブルにする。
JOINしなくてもいい感じ。

## クエリスタック

ドメイン固有のクエリとアプリケーション固有のクエリが存在する。
ビジネスルールがフィルターとして表現される。
ビジネスルールは合成したり、再利用したりすることが可能。

概念的なクエリもしくは戻り値の型に対してクエリを定義するパターン。
LET（式木？）でやるパターン★
→クエリビルダーでクエリを構築する。フレームワークやDBServerと密結合になる。

## コマンドスタック

コマンドの結果をクライアントにどのように連携するかを考える必要がある。
対話形式？の画面であればコマンドのレスポンスを使って、画面を再描画する。
HTTPリクエストの場合はコマンドの結果を参照するURIを返却する。

コマンドやそれにより発生するイベントは抽象化するとメッセージとして捉えられる。

メッセージにはコマンドとイベントがある。
コマンドは命令型のメッセージ。一つのハンドラに送信され、実行される。拒否されることもあるし、失敗することもある。結果はサーバーの状態によって異なる。
イベントは発生したことの通知としての役割を果たす。拒否されることもある。イベントハンドラはたくさん指定しても構わない。イベントが連鎖することもある。イベントのサブスクライバはコンテキスト境界の向こう側にあるかもしれない。

どちらもユビキタス言語によって適切に命名される。

コマンドはコマンドバス、イベントはイベントバスによって管理される。
コマンドと関連するイベントを処理するプロセスはSagaと呼ばれる。
コマンドバスはリクエストやイベントの通知を受け取り、処理するためのハンドラを見つけるクラス。

Sagaコンポーネント（ハンドラ？）
Sagaに関連づけられているプロセスを開始するためのコマンドorイベント
Sagaが処理できるコマンドとSagaが関心を持つイベント
Sagaは一つのワークフローとしてみなすことができる。
アプリケーションサービスのことなのか？

データベースをクエリとコマンドで分割するのか問題。
非正規化されたクエリキャッシュをつくればよい？マテリアライズドビューとか関係ありますか？
キャッシュを適切なタイミングで更新することが必要。

# 第１１章 CQRSの実装

## CQRSの実装

実装の仕方にはいくつかある。

読み取り用のドメインが薄く、データをプレゼンテーション層に届けるためのDTOとSQLだけで構成されるもの
クエリスタック用のドメインモデルとビジネスロジックが含まれるコマンド用のドメインモデル
コマンド側を軽量にしてトランザクションスクリプトパターンで頑張る

多くの場合は、コマンドスタックはコマンドバスに基づいて、ドメインモデルとデータベースに基づいて処理する。
データベースは2つ存在していて、アプリケーションの状態が格納されるものと、クエリに最適化されたデータが格納されるものがある場合は、同期する仕組みが必要（トリガー）

### 単純なCQRS

ビジネスロジックを表現するために理想的なパターンと、表示用に最適なパターンを特定する。
ビジネスロジックは、ドメインモデルパターンとトランザクションスクリプトパターンのどちらかで実現sルウ。
表示用にはDTOを使用する。DTOをさらにViewModelに加工するか、ViewModelをそのまま返すか選択できるが、基本的には後者が現実的。
データベースは1つ。

### CQRSとコマンドアーキテクチャ

コマンド駆動戦略とイベントとの併用をする。
アプリケーションサービスでオーケストレーションしているステップをイベントとハンドラに分割。
この場合は読み込みと書き込みでデータベースを分割することが多い。
同期する方法は、定期的にコピーする方法と、コマンドが実行された後に同期を行う方法がある。

## クエリスタックの実装

クエリモデルは読み取り専用のドメインモデル。振る舞いは持たず、全て状態として持っている。
アプリケーションで必要なデータを読み込むリポジトリ？Dao？を定義する。
戻り値がコレクションの場合は、読み取り専用でLETが使えるIQueryableを使う。
ビジネスロジックをExpressionとして実装し、使い回す。

サービスで複数のクエリスタックを結合して、プレゼンテーション用のモデルに変換する。

## コマンドスタックの実装

コマンドとイベントの観点からワークフローを定義する。
Sagaコンポーネントを実装する。

- Sagaを開始するメッセージのリスト。
- Sagaが処理できるコマンドのリスト。
- Sagaで処理できるようにしたいイベントのリスト

### Sagaコンポーネント

Controllerでリクエストを元にコマンドを生成する。
イベントバスに生成したコマンドを送る。

イベントバスにコマンドが送信されると、コマンド（メッセージ）に対応したSagaコンポーネントのインスタンスが生成される。
さらにSagaコンポーネント内で数珠繋ぎのようにコマンドやイベントがバスに送信される。
これはフローチャートに似ている。
コマンド内で正常系と異常系の分岐があるとする。
正常系と異常系それぞれがイベントとなりうる。コマンドではこれらのイベントを送信する。
正常系で続けてなんらかの処理を行う場合、正常系のイベントをハンドリングして、後続のコマンドメッセージを送信する。

最初のハンドラでの課題は、SagaのインスタンスのIDを特定すること。
Sagaコンポーネントは何らかの方法によってユーザーごとにインスタンスを管理する。
セッションIDや集約のIDをキーにする。
クラッシュしたら途中から再開できるようにする。

Sagaは永続的でなければならない？
→クラッシュした時に再開できるようにする必要があるから、どこかに途中経過を退避させておく必要がある。

コマンドやイベントの粒度はユビキタス言語のレベルで定義される。

# 第１２章 イベントソーシングの紹介

データモデルの作成よりもドメインモデルの作成を奨励するDDDは、リレーショナルモデルに対する突破口になった。？？？？？？

イベントの永続化はコマンドスタックとクエリスタックを切り離すという戦略と結びつく。
アプリケーションの状態の保存とプレゼンテーション層へのそれらの提供に別々のデータベースを使用する。
イベントソーシングはDomainModelやCQRSをさらに特徴づけるために使用される。
イベントソーシングを実装するには、それ専用のツールが必要になる。

## イベントの躍進

イベントに着目する考え方は一部のビジネスドメインでは昔からあった。

アプリケーションのアクションの一つ一つが仕組まれたモデルの中で発生するという方法の場合は、モデルを全て把握している必要がある。忠実にドメインを再現することが難しい。
小さいコンテキスト/ドメインに分割した方が管理しやすい。

モデルは概念上に存在するものでしかなく、現実世界で直接目にするものは事象（イベント）である。
現実の世界ではアクションを起こすと、アクションが反応を起こす。
反応はすぐに発生することもあれば、そうでないこともある。
反応が他のアクションを引き起こすこともある。

イベントソーシングの焦点は一連のイベントで、モデルの状態ではない。

Orderエンティティについて。状態に未処理、発送済み、キャンセル、アーカイブ済をもつ属性がある。
ストレージに永続化する特定の注文に関する情報は、現在の情報か、最後に確認された正常な状態。
ステータスは特定のドメインイベントが発生した時に更新される。
注文の作成、処理、キャンセルは最後に確認された正常な状態を変更する。

最後に確認された正常な状態の状態を変更してしまうと履歴の追跡ができなくなってしまう。
注文のIDと変更日時をキーに持つ。あくまで変化する状態だけをイベントに保持する。全てのモデルの全ての情報を履歴に保持するわけではない。

他にも既存の注文に商品が追加/削除されたり、必須のカラムが増えたり減ったりしたときにどうするか。
リレーショナルモデルではデータの修正やコードの修正が必要になるが、非リレーショナルモデルでは変更の影響はそこまで大きくない。
最後に確認された正常な状態アプローチはアプローチの一つに過ぎない。アイテムのライフタイムを効果的に表すことができない。

イベントをもとにモデルを構築する必要がある。
一方でエンティティベースのモデルはクエリとの相性は抜群だが、コマンドでも同じとは限らない。
コマンドとクエリは分割した方が良い。
イベントはシステムの主なデータソース。
イベントが発生すると、そのイベントが関連づけられているデータの集まりが保存される。
世界はイベントでできているので、ほとんどのビジネスドメインがはるかに自然にモデリングされる。

イベントの利点は、分析によって浮かび上がったドメインイベントをいつでも追加したり保存したりすることができる。システムで起きているほぼ全てのことを簡単に追跡できる。
イベントにはざまざまなフォーマットがある。

イベントは特定ドメインでのビジネスストーリーを完全に伝える。
ビジネスストーリーを一連のイベントとして記録すると効果的。

モデルを使ってビジネスストーリーを永続化すると、表現できるのがモデルの境界内のものに限定される。
イベントではそのような制限が根本的に削除され、新しい別のビジネスシナリオのサポートが可能になる。

イベントストア
イベントの格納と処理で、ビジネスストーリーの現在の状態をいつでも必要な時に再現できうるようになる。
イベントの再生という。
特定の日のビジネスの状態を知るという場合にも対応している。

イベントベースのストレージを利用すれば、イベントを再生し、実行時の状態の一部を変更し、結果がどうなるかを確認するのも簡単です。うれしいことに、こうした仮定のシナリオを適用するにあたって、アプリケーションでまったく別のアーキテクチャを使用する必要はありません。イベントソーシングアプローチに従ってシステムを設計すれば、特定の状態を仮定したシナリオが自動的に有効になります。

イベントソーシングでは特定のソフトウェアツールが必要になる
イベントストアを使用することは発生したイベントを記録する。
クエリは利用可能なデータをイベントのログから再現する必要がある。
コマンドスタックとクエシルタックを接続するためのメカニズムが必要。

コマンドとクエリを切り離したまま、同期処理のコストをかけずに同期させることでスケーラビリティを向上させたいならサービスバスコンポーネントが向いている。

イベントソーシングの欠点
イベントソーシングの考え方が開発者に馴染みなかったり、IDE・フレームワークがサポートしてなかったりする。

本当にイベントソーシングを使用するメリットが見当たらないなら使うべきではない。
イベントが重要となるのは寿命の長いエンティティを扱うビジネスシナリオ。予約や会計などのシナリオで重要。
ドメインイベントが存在するからと言って、その全てを追跡する必要があるかというと別の問題である。
イベントが特定のロジックだけに使用されるなら不要。永続化する必要があると考えられる時のみ使用する。

## イベントソーシングアーキテクチャ

システムの監査ログを形成したい場合はイベントソーシングを使用した方がよい。

イベントを物理ストアに永続化する問題点
イベントストア
→イベントが参照するオブジェクトの状態を再現するのに役立つ情報からなるイベントオブジェクトが含まれる
→指定されたキーに関連づけられている一連のイベントを返せなければならない。
→追加専用

イベントはアトミック。
イベントは発生した特定の事実についてのみ表す。
全てを組み合わせることでアプリケーションの現在の状態がわかる。

イベントストアはRDBMSかドキュメントデータベースがある。
イベントの形が将来にわたって変わらないような場合はRDBMSを使うのがよい。
NoSQLは書き込まれた内容が読み込まれるようになるまでタイムラグがある。

イベントストアはパフォーマンス（データ量など含めて）に注意が必要。

ビジネスエンティティの状態を再現するための問題点
メッセージの永続化により、状態変化を全て追跡できるようになる。
状態を再現するにはメッセージのログを読み戻す。
状態変化する前後で整合性を保たれていたかどうかなどを確認するには
空の注文に対してイベントを再生していく必要がある。

パフォーマンスの問題
数十件のイベントであれば問題ないが、百件以上のイベントを処理する必要がある場合はスナップショットを保存した方がよい。
スナップショットはイベント100個を目安に定期的に作成する
スナップショットは一部で十分な場合もある。
もしくは各処理の最後に集約を更新する解決法もある。
