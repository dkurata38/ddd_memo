## ドメイン駆動設計

大規模なシステムを設計する際に使用されるアーキテクチャのアプローチです
リアクティブアーキテクチャと似ている概念です
大きなシステムや大きなドメインを小さい断片に分割するのが重要な目標です
大きなシステムをマイクロサービスに分割する境界線を決めるのに役立つガイドラインを提供します


## ドメイン

ドメインとは知識の特定の領域のことです。
モデル化しようとしているビジネスやアイデアのことです。
ドメインエキスパートとはソフトウェアの専門家ではなく、ビジネスやアイデアに精通している人のことです。
ユビキタス言語でコミュニケーションをします。
ユビキタス言語は技術的な用語ではなく、ドメインエキスパートが使っている言葉を使います。

モデルはドメイン知識への理解です。
ソフトウェアやダイアグラムはモデルの実装であり、モデルそのものではありません。
開発者はモデルをソフトウェアによく反映することが必要です。

## ドメインの分解

### サブドメインへの分割

ドメインには多くの複雑さがある。
様々なアクターやオブジェクトが複雑に相互作用していることが多い。
これを一度にモデル化するのは困難です。
関連するアイデアやアクション・ルールをグループ化します。

複数のサブドメインにまたがって共通する概念があるかもしれません。
サブドメインによって必要な情報は違うので共通化しない方がよいです。

### 境界づけられたコンテキスト

モデルとユビキタス言語とサブドメインと境界づけられたコンテキストは1対1です。
マイクロサービスを境界づけられたコンテキストで分割することは多い。

境界づけられたコンテキストは人間の文化や相互作用を考慮して分割をする。
アクターの種別や仕事をしている場所によって分割をする。
同じ言葉が異なる意味を示しているとき、それらの言葉は異なる境界づけられたコンテキストに属する可能性がある

### イベントストーミング

オブジェクトだけではなくアクティビティやイベントに注目する技法。

## ドメインアクティビティ

以下の演習では、主語-動詞-動詞-動詞の表記法を使います。この記法の目的は、ドメイン内での活動や出来事を一貫した言い回しで表現できるようにすることで、後になってそれらに戻ってきたときに、有用な情報を抽出するためにその技術を使うことができるようにすることです。このように、主語-目的語-主語-目的語の表記法は、「ホストは現在の予約状況をチェックします」のような例文を取ると、この場合、私たちがしていることは、最初に主語、最後に目的語、そして真ん中に動詞があるように文をフレーズ化していることです。この場合、主語はホストです。主語は実行されている行動をしている人と考えることができます。ホストは行動をしているということですね。行動とは何でしょうか？さて、アクションは、ホストが現在の予約を確認していることです。それは2つの部分に分かれています：最初は、動詞は、チェックしているし、2番目は、オブジェクトは、現在の予約です。だから我々は "ホストが現在の予約をチェックしています" 主語-動詞-オブジェクトの表記法です。オブジェクトを単純化することができます。我々は、その現在の予約と言うことができますが、我々はおそらく、現在の予約は本当に予約の修飾子だけであることを言うことができます。だから、一日の終わりに予約は本当に我々が焦点を当てようとしているオブジェクトです。これが主語-副詞-オブジェクトの表記法です。私たちは後の演習でそれを使用するつもりです私たちは文からいくつかの情報を抽出するのに役立ちます。

## 境界づけられたコンテキストの純粋さを保つ

### 腐敗防止層

コンテキスト間の依存を防止する
異なる境界づけられたコンテキストのドメインオブジェクトを変換する
抽象インターフェースで表す
コンテキスト間の関係はコンテキストマップを使って示す


バインドされたコンテキストをきれいな境界線に分離した後は、明確な境界線を維持し、バインドされたコンテキストの純度を維持するという、ちょっとした仕事が待っています。そのためには、それを可能にするテクニックが必要です。それを可能にする一つの方法として、私たちが「汚職防止層」と呼んでいるものがあります。バウンデッドコンテキストを持つとき、それぞれのバウンデッドコンテキストが独自のドメイン概念を持っている可能性があることを認識することが重要です。

例えば、この図を見てみると、予約コンテキストと顧客コンテキストがあります。ここでは、顧客に固有の顧客の特定の側面があります。その例として予約アドレスには関係ありません。また、常に1つのコンテキストから次のコンテキストに互換性があるわけではない概念があります。時には何が起こるかは、例えば、予約のコンテキストでは1つのことと呼ばれ、顧客のコンテキストでは何か別のものと呼ばれている概念で終わる可能性がありますです。または何かがいくつかの種類の翻訳を必要とするような方法で互換性がない状況で終わるかもしれません。多分その別の単位またはそのような何かで記録され、我々 はそれを翻訳する必要があります。

要するに、このような制限された文脈の間では互換性がないという状況に陥る可能性があるということです。私たちが望んでいないのは、ある種の抽象化や、すべてのバウンデッドコンテキスト間で同じにする方法を考え出すことです。例えば、顧客の表現には、住所、電話番号、いつ顧客になったか、その顧客についての詳細が含まれています。この顧客表現をあらゆる場所で使用することができれば、そのことを気にする必要はありません。しかし、これではカップリングが発生してしまうので、それは避けたいところです。例えば、このようにして住所の構造を変更した場合、それは一つの方法で表現されていたかもしれませんが、より良い表現方法があることに気づき、追加の情報を追加したり、一部の情報を削除したりします。さて、もし私たちがすべての場所でそれを使用していたならば、今、私たちは予約コンテキストを更新する必要があります。


だから今、我々は不必要なカップリングを作成したし、我々はそれを回避したいです。破損防止レイヤーを使用すると、このような事態を回避することができます。それが何をするかは、それが何であれ、その顧客コンテキスト表現を見て、それは予約サービスに固有の表現に変換します。住所のような不必要な情報を取り除きます。言語変換が必要な場合は、それを行います。その結果、予約コンテキストは、それが気にする純粋な表現のみを処理します。これにより、束縛されたコンテキストがお互いに漏れるのを防ぎますが、束縛されたコンテキストを独立させることもできます。例えば、不正行為防止層の内部にキャッシュ層がある場合、顧客コンテキストが何らかの理由で消失しても、不正行為防止層はその情報のキャッシュを保持している可能性があります。そして、顧客のコンテクストがなくなったにもかかわらず、動作することができるかもしれない。


腐敗防止層はどのように実装されているのでしょうか？それを実装する一般的な方法は、抽象的なインターフェースとして実装することです。抽象インターフェースは、データの純粋なドメイン表現のようなものです。そして、必要な変換を行うインターフェイスの実装があります。そして、その変換を行うインフラストラクチャコンポーネントのようなものです。予約のコンテキスト、顧客のコンテキストなど、純粋な境界のコンテキストを持っている状況です。私たちはそれらの境界をかなりよく理解しています。それは常にそうとは限りません。 時にはレガシーシステムとのインターフェイスが必要になることもあります。レガシーシステムでは、ドメインが乱雑であったり、不明確であったりします。この場合、レガシーシステムのドメインを理解するために時間をかけた人はいないかもしれないので、この場合、腐敗防止レイヤはレガシーシステムの混乱を純粋なバウンデッドコンテキストから遠ざける役割を果たします。これにより、ドメインがその混乱に対処する必要がなくなるのです。この場合、腐敗防止レイヤーは2つの場所に配置されています。予約コンテキストとレガシーシステムの両方にあります。両方の場所で確認できます。技術的には、どちらか一方に設置しても、両方に設置しても構いません。私が一般的に推奨するのは、純粋なマイクロサービスや純粋なバウンデッドコンテキストが何らかの種類の他の外部サービスと通信する必要がある場合はいつでも、汚職防止レイヤーを介して通信することです。予約コンテキストは、外部サービスと通信するために常に不正行為防止レイヤーを持つべきです。今すぐ逆に、あなたのレガシーサービスで何をしたい場合がありますが、それの複雑さのためには、予約コンテキストのためだけのAPIを公開することがあります。これは、純粋な表現のもう少しを持っています。それは完全に純粋ではありませんが、それはあなたの厄介なレガシー システムは通常公開されているだろう何からより多くのビットをクリーンアップです。そのため、レガシーシステムで公開しても問題ないかもしれませんが、その場合でも、予約コンテキスト側にも汚職防止レイヤーを用意することをお勧めします。



## ドメインアクティビティ

ドメインアクティビティを定義することで、境界づけられたコンテキストの分析に役立ちます。

### ドメインアクティビティの種別

1. コマンド

アクションを実行するためのリクエストのこと
特定の受信者がコマンドを受信するとドメインの状態に変化が生じる
コマンドは拒否される可能性がある
コマンドは詳細のレスポンスを返さない

2. イベント

イベントは過去に発生するアクションを表しています。
拒否することはできないが無視することはできる。
イベントはドメインの変更を記録する

3. クエリ

クエリは常に詳細のレスポンスを返す
クエリはドメインに変更を加えない

## ドメインオブジェクト

### 値オブジェクト

値オブジェクトは属性によって識別される
値オブジェクトは不変である
いずれかの属性が書き変わると別の値オブジェクトとなる
リアクティブシステムではメッセージは値オブジェクトとして実装される

### エンティティ

IDによって識別される
変化する可能性がある
属性が異なっていてもIDが一致すれば同じオブジェクトとしてみなされる
属性が同じでもIDが一致していなければ異なるオブジェクトとしてみなされる
Akkaのアクターはエンティティのモデルです

### 集約

ルートエンティティに結合されたドメインオブジェクトの集合体である
ルートエンティティは必ずエンティティである
集約内のオブジェクトにアクセするには集約を経由する必要がある。
トランザクションの単位と集約の単位を跨らないようにする
このルールに違反した場合、集約の単位を考え直した方が良い。
集約単位で分散システムを構築することもある。

### 集約の探し方

あるコンテキストで集約ルートであるエンティティが別のコンテキストでも集約ルートであるとは限らない
集約ルートは境界づけられたコンテキスト一つにつき一つ定義する。
ほとんど全てのアクティビティに関わっているようなエンティティを集約ルートとして考える	


## ドメインの抽象化

### サービス

サービスはステートレスです
特定のエンティティや値オブジェクトに収まらないビジネスロジックをサービスでカプセル化をします
腐敗防止層を抽象化するために使います
サービスをたくさん使うとドメインが貧弱になる

### ファクトリ

新しいオブジェクトの構築に対する抽象化
一つ以上の実装がある
ファクトリはCRUDのCreate
対してリポジトリはCRUDのRead、Update、Deleteを行う

### 特徴

リポジトリは必ずしもデータベースの上にあるレイヤーではない
サービス、ファクトリ、リポジトリ共に抽象なので実装を入れ替えられる。


## ヘキサゴナルアーキテクチャ

ドメインを中心とするアークテクチャ
ドメインには公開されているポートがあり、APIとして機能します
アダプタはポートとAPIを介して通信をする

レイヤーは内側に依存することはあるが逆は許されない。
ドメインはデータベースもユーザーインターフェースも知らない。
プロジェクトやパッケージを使って依存関係をコントロールすることもできます。


ドメイン駆動設計とよく組み合わされる特定の技術は、六角形アーキテクチャと呼ばれています。六角形アーキテクチャはドメイン駆動設計とは直接関係していない。六角形アーキテクチャを使用せずにドメイン駆動設計を使用することはできますが、ドメイン駆動設計とは非常に互換性があります。そのため、六角形アーキテクチャがドメイン駆動設計と併用されているのをよく目にしますし、ドメイン駆動設計に関する多くの文献で目にすることができます。六角形アーキテクチャの概念が出てくるのを目にすることがあるでしょう。六角形アーキテクチャとは何ですか？ポートとアダプタとしても知られています。ポートとアダプタのアイデアであり、六角形アーキテクチャはアリスター・コックバーンという人物によって提案されました。基本的には、皆さんがよく知っているかどうかは別として、レイヤードアーキテクチャやN層アーキテクチャの代替案です。よく知らないかもしれませんが、n 層アーキテクチャとは、アプリケーションを異なるレイヤーに分離するという考え方です。通常、一番下にはデータベース層があり、一番上にはある種のユーザーインターフェース層があり、真ん中のどこかにドメイン層のようなものが挟まれています。レイヤーの数は誰と話すかによって異なりますが、3つから5つ、または7つの間のどこかにあることを知っています。一方の端にはユーザーインターフェース、もう一方の端にはデータベースを配置し、他の多くの層を中間に配置して、ドメインを重要な層の1つにしようという考え方です。六角形アーキテクチャは、ここでは一種の異なるアプローチをとります。ドメインがN層アーキテクチャのサンドイッチのようなものの真ん中にあるのではなく、ドメインが中心にあり、この場合は六角形ですが、他の図面では玉ねぎのような形をしています。ここでの考え方は、ドメインはコアであるということです。ドメインはアプリケーションにおいて絶対的に最も重要なものであり、したがって中心にあるべきものです。そこで、ドメインによって公開されているポートがあります。これらのポートは基本的にはAPIとして機能します。これらのポートはドメインと通信するための好ましい方法です。そして、インフラストラクチャアダプタと呼ばれる一連のものがあります。これらのアダプタはポートと通信し、そのAPIを介して通信します。六角形にはさまざまな側面があります。一方にはユーザー側のAPIのようなものがあり、もう一方にはデータ側のAPIがあります。実際にこれを裏返してみると、上がユーザー側のAPI、下がデータ側のAPIになっています。この時点で、N層アーキテクチャに似てきます。

多くの点で、これは n 層アーキテクチャの考え方を別の方法で表現しているに過ぎません。しかし、六角形アーキテクチャには、必ずしも n 層アーキテクチャではあまり語られていない、追加のルールがいくつかあります。これらの追加ルールは、いくつかの利点を提供します。前にも述べましたが、これはたまねぎとして描かれていることがあります。ここでは、玉ねぎと六角形を組み合わせて図面にしてみました。ここでも中央に領域が描かれています。このドメインの外側にはもう一つのレイヤーがあります。私はサービスという言葉は避けたいと思っています。サービスやドメイン駆動設計は非常に特殊なものを意味するからです。また、私はAPIという言葉の方が少し好きです。これは意味をかなりよく捉えていると思います。ドメインはAPIを公開していますが、これはその外側にある別のレイヤーです。そして、その外側にはインフラストラクチャ層があります。 ここでの考え方は、ドメインが玉ねぎの中心であり、APIがポートを提供し、それは別のレイヤーであり、インフラストラクチャがポートと通信するアダプタを提供するというものです。ここで重要なのは依存関係です。外側のレイヤーは内側のレイヤーに依存することが許されていますが、逆は真ではありません。インフラストラクチャはAPIに依存することができ、APIはドメインに依存することができますが、ドメインはAPIやインフラストラクチャが存在することを知りません。これは非常に興味深い結果をもたらします。これは、六角形アーキテクチャがインフラストラクチャとドメインの適切な分離を保証することを意味する。ドメインがインフラストラクチャを知らないことを保証することができます。ドメインはデータベースについて知らない。ユーザーインターフェイスについても知らない。それは許可されていないので、それらのことを知りません。これらのルールはそれを防ぐため、データベースやユーザインタフェースなどの懸念がドメインにまで波及するのを防ぎます。これはパッケージを使って強制することができます。私がプロジェクトでよくやることは、ドメインパッケージ、インフラストラクチャパッケージ、APIパッケージを作成することです。そして、ドメインパッケージがインフラストラクチャパッケージの何かを参照しないようにするために、検索などを行います。しかし、これはプロジェクト構造を使って行うこともできます。依存関係を持つプロジェクトとして設定した場合、ドメインをAPIやインフラストラクチャに依存させることができないようにすることができます。もし依存関係を作成した場合、循環型の依存関係が作成され、コンパイルできなくなります。これにより、ドメインを移植できるようになります。つまり、ドメインに影響を与えることなく、インフラの一部を簡単にスワップアウトできるようになります。別のデータベース実装にスワップすることができます。別のデータベースである必要はなく、同じデータベース内の別のテーブル構造であっても構いません。しかし、ドメインに影響を与えることなく、異なる構造にスワップすることができます。ドメインはSQLを使用していることを知りません。また、Cassandraを使用していることも知りません。ドメインの観点からは、これらの変更は無関係になります。他にも、APIやインフラストラクチャに影響を与えることなく、ドメイン内で変更を行うことができます。私はこの手法を使用したことがありますが、ドメインで行ってきたことが根本的に欠陥があることに気付きました。私たちは、APIやインフラストラクチャに何も変更を加えることなく、特定のマイクロサービスのドメイン全体を書き換えました。このようにきれいに分離されているので、アプリケーションの外部クライアントはそれらについて知る必要がありません。このように分離されているので、何かが変更されたことを知る必要はありません。したがって、六角形アーキテクチャを中心に設計されたシステムは非常に柔軟性に富んでいます。様々な方法で変更することができ、クライアントへの影響を最小限に抑えることができます。これは非常に強力なテクニックです。もしあなたがn-tiered architectureを使うことに慣れていて、何年も使っていて、良い仕事をしているのであれば、それを使い続けてもいいと思います。しかし、過去に n 層アーキテクチャに問題があった場合や、新しいものを探している場合、または n 層アーキテクチャのことを聞いたことがない場合は、六角形アーキテクチャをもっと深く見てみることをお勧めします。六角形のアーキテクチャは、多くのパワーを与えてくれるし、システムの中で何かを変更するための柔軟性を与えてくれる。リアクティブツールのいくつかである Akka や Lagom は、実際に六角形アーキテクチャを非常にうまく活用しています。六角形アーキテクチャの概念を利用して、インフラストラクチャのニーズの多くを抽象化しています。つまり、永続性、配布、通信はすべてツールキットに組み込まれているのです。これらはすべてインフラストラクチャの問題です。これらはツールキットに組み込まれているので、多くの場合、異なるプラグインを使用してそれらを交換することができます。これが意味するのは、インフラストラクチャについてあまり心配する必要がなく、ドメインに集中できるようになったということです。永続性、配布、通信などはすべてツールキットで管理されているので、心配する必要はありません。そして、ドメインの構築に集中できるようになりました。	

