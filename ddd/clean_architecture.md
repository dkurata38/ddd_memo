# クリーンアーキテクチャ

## まえがき・序文

アーキテクチャとはシステムを形作る、変更コストの大きい重要の設計決定を表したものである。

ソフトウェアとそのアーキテクチャには難しさが3つある。

1. ソフトウェアは構造の数も種類も多様である。
2. ソフトウェアアーキテクチャの本質は目に見えない。
3. 将来の開発者やユーザのニーズを満たす必要がある一方でそれはとても困難である。

将来を予測することは難しいのでソフトウェアの柔軟性を受け入れるところから始まる。

作るソフトウェアやハードウェアが時代によって変化したりしても、アーキテクチャのルールは変わらない。
本書ではそのルールについて記す。

## 第1部 ソフトウェアアーキテクチャの重要性

ソフトウェアを動かすのはそれほど難しくないが、ソフトウェアを正しくするのは難しい。
ソフトウェアを正しくすると以下のようなメリットがある。

1. 開発や保守に必要な人がはわずかで済む。
2. 変更が簡単で迅速になる。
3. 欠陥の数が少なくなる。

### 第1章 設計とアーキテクチャ

アーキテクチャと設計はそれぞれ上位レベルと下位レベルの構造や意思決定を指していると一般的に捉えられている。
実際にはアーキテクチャと設計は連続した構造を作っている。
最上位レベルから最下位レベルまで、決定の連続である。

ソフトウェアアーキテクチャの目的は、求められるシステムを最小限のコストで構築・保守するためのものである。
システム構築・保守の生産性は以下のメトリクスを確認する。

1. リリースごとのエンジニア数の増減
2. リリースごとのソースコード行数の増減
3. 1と2をもとにした、リリースごとのコード行あたりのコスト

システム開発では、リリースを急ぐあまりコードをクリーンするのを後回しにしがちである。
実際には、ソフトウェアアーキテクチャと向き合い、クリーンなコードを開発したほうが短期的にも長期的にも生産性が高い。

### 第2章 ソフトウェアの価値

ソフトウェアは振る舞いとアーキテクチャという2つの価値をステークホルダーに提供する。

#### 振る舞い

ステークホルダーの収入を増やしたり支出を減らしたりできるようにするための振る舞いを実装する。
ステークホルダーが作成した機能仕様や要件に基づいたソフトウェアを開発する。

### アーキテクチャ

ソフトウェアを簡単に変更できるような構造にする。
ソフトウェアは変更を重ねるごとに複雑になりがちだが、それとは関係なく変更の難易度がスコープに比例させることが重要である。

### 2つの価値とジレンマ

2つの価値のうち大きな価値をもつのはアーキテクチャである。
なぜなら要件が変わろうが、不具合が発生しようが、修正できさえすれば良いからである。

コードのアーキテクチャは重要性が高く、振る舞いは緊急性が高い。
ソフトウェア開発者はアーキテクチャの重要性を正しく評価することが求められる。

## 第2部

### 第3章 パラダイムの概要

#### 構造化プログラミング

直接的な制御（ジャンプ）などの制御の移行に制限をかけ、ifなどの抽象的な構文に置き換えた。

#### オブジェクト指向プログラミング

間接的な制御の移行に制限をかけた。

#### 関数型プログラミング

代入に制限をかけた。

#### まとめ

それぞれのパラダイムがアーキテクチャの関心事「コンポーネントの分離」「機能」「データ管理」に対応している。

### 第4章 構造化プログラミング

#### 数学的証明と機能分割

プログラミングに数学的な証明を持ち込もうと試行した。
goto文を使うことによって、モジュールを再起的に分割できなくなり、合理的な証明に必要な分割統治を使えなくなることがわかった。
goto文をうまく使えば、「選択」「反復」という制御構造に対応することがわかった。
プログラムを「順次」「選択」「反復」の3つの構造で構築できるとした。
この主張が認めるあれ、最近のプログラミング言語ではgoto文がサポートされなくなった。

制御構造と同様に、モジュールを証明可能な単位に分割する構造化分析が流行った。

#### 科学的な証明とテスト

数学的証明は命題が真であることを証明する一方で、科学的証明は命題が偽であることを証明する。
科学的証明の考え方はソフトウェアのテストに持ち込まれた。

ソフトウェアのテストは、バグが存在しないことを示すのではなく、存在することを示すものである。
つまり、どれだけ最善を尽くしてもバグの存在を証明できないことで、正しさを明らかにしている。

ソフトウェアテストを念頭におくと、反証可能な単位まで機能を分割していくことがアーキテクチャレベルにおいてベストプラクティスだと考えられている。

### 第5章 オブジェクト指向プログラミング

オブジェクト指向プログラミングでは「カプセル化」「継承」「ポリモーフィズム」という言葉で説明されることがある。
オブジェクト指向言語の登場により継承とポリモーフィズムを便利に扱えるようになった。

特にポリモーフィズムhz制御の流れと依存関係を逆転させることができるので、コードの依存関係をコントロールできるようになった。
アーキテクチャの視点では上位のビジネスロジック層に下層のUIやデータベースの層を依存させ、上位モジュールのデプロイを下位モジュールから独立させることができるようになった。

以下、C言語との比較。

#### カプセル化

プライベートなデータメンバーとパブリックなメンバー関数。
C言語のときからあった。
C言語ではデータ構造と関数をヘッダファイルに宣言して、ユーザからアクセスできない実装ファイルで実装をしていた。
Javaなどのオブジェクト指向言語はヘッダファイルと実装が統合されたので、カプセル化は弱体化した。

#### 継承とは

スコープないの変数と関数のグループを再度宣言するもの
オブジェクト指向言語じゃなくてもできる

C言語では多重継承するのがむずかしい。
アップキャストが暗黙的に行われる。確かにオブジェクト指向言語のほうが継承はいい感じ。

#### ポリモーフィズム

C言語にもあった
IOデバイスドライバに対して特定の関数の実装を求めることがあった。
構造体、関数ポインタ

オブジェクト指向言語によってポリモーフィズムを安全に便利にしてくれた。
C言語のときに意識する必要があった関数をポインタを経由して呼び出すという規約がなくなった。

### 第6章 関数型プログラミング

#### 不変性とアーキテクチャ

可変性は競合状態、デッドロック、並行更新などの問題を引き起こす。
可変変数がなければ並行処理を行うアプリケーションで直面する問題を回避できる。
ストレージとプロセッサの速度の観点からある程度妥協ができれば不変性は実用性がある。

#### 可変性の分離

一般的には可変コンポーネントと不変コンポーネントを分離することで妥協をする。
不変コンポーネントは可変変数を使わず関数的にタスクを行う。
不変コンポーネントは変数の状態の変更を許可しているコンポーネントと通信をする。
可変コンポーネントはトランザクショナルメモリを使用することで並行更新や競合状態から保護する。
できるだけ不変コンポーネントに処理を押し込んだほうがいい（なぜ？）

#### イベントソーシング

イベントソーシングは状態ではなくトランザクションを保存する。
状態を定期的に計算しておいて、キャッシュしておくことも可能。
イベントソーシングでは削除や更新をしない。
アプリケーションに十分な処理能力があれば関数型プログラミングを使った仕組みであると言える。

### まとめ

様々なプログラミングパラダイムにおいて、コーディングの仕方に様々な制限をかけてきた。
一方でできることは前から変わっていない。
ソフトウェアは順次、選択、反復と間接参照で構成されている。

## 第3部 設計の原則

SOLID原則を使って考える。
オブジェクト指向言語以外にも適用できる。

SOLID原則の目的は以下のような性質を持つモジュール（中間ソフトウェア）を作ること。

1. 変更に強いこと
2. 理解しやすいこと
3. コンポーネントの基盤として多くのシステムで利用できること

### 第7章 単一責任の原則

個々のモジュールを変更する理由がたった一つになるように。
モジュールはたった一人のアクター（ユーザーやステークホルダーの分類）に対して責務を負う。
モジュールとは凝集性のある関数やデータをまとめたもの。

複数のアクターに対して責務を負うと、要件や仕様の変更によるコードの変更がコンフリクトしがちである。
アクターごとにオブジェクトを用意して、アクターオブジェクトがデータに依存するようにする。
一つのデータに対して振る舞いを一つのクラスにしたい場合はFacadeクラスが複数のアクターオブジェクトに依存するようにすれば良い。

### 第8章 オープンクローズドの原則

ソフトウェアの振る舞いは既存の成果物を変更せず拡張できるようにする。
インターフェースで依存関係の方向を制御することで、ビジネスロジックを包含するような上位モジュールを下位モジュールの変更から保護することができる。
インターフェースによってモジュール内部のユーザーが直接使っていないエンティティへの推移的依存関係を防ぐことができる。

### 第9章 リスコフの置換原則

派生型を基本型に置き換えても振る舞いが変わらないようにする。
インターフェースに依存していれば派生型の実装が何であろうと振る舞いが変わらないことに依存しているから。

### 第10章 インターフェイス分離の原則

必要としないモジュールには依存しないようにする。
依存しているモジュールのうち利用していない部分が変更されたときに、再コンパイルと再デプロイをしなくてすむようにする。
複数の責務を持つクラスを実装するにしても、モジュールが利用する部分ごとにインターフェースを分離して、クラスが複数のインターフェースを実装するようにする。

### 第11章 依存関係逆転の法則

抽象宣言だけを含むソースモジュールに依存するべきである。
関数の変化しやすい実装を含む具象モジュールに依存しないようにする。

1. 変化しやすい具象クラスを参照しない。
2. 変化しやすい具象クラスを継承しない。
3. 具象関数をオーバーライドしない。

具象オブジェクトを生成するときはAbstract Factoryパターンを使う。
抽象コンポーネントを生成するファクトリの抽象にアプリケーションは依存し、ファクトリの具象が具象オブジェクトを生成する。

## 第4部 コンポーネントの原則

### 第12章 コンポーネント

コンポーネントはデプロイの最小単位のことである。

### 第13章 コンポーネントの凝集性

#### 再利用・リリース等価の原則

再利用の単位とリリースの単位は等価になる。
コンポーネントを形成するクラスやモジュールは凝集性のあるグループである。
一つのコンポーネントを形成するクラスやモジュールはまとめてリリース可能である。

#### 閉鎖性共有の原則

単一責任の原則のコンポーネントバージョン。
異なる理由、異なるタイミングで変更されるクラスはの別のコンポーネントに分けること。
同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめること。
このようにすればリリース時の作業を最小限にできる。
オープンクローズドの原則とも関連している。

#### 全再利用の原則

コンポーネントのユーザに対して実際に使わないものへの依存を強要してはいけない。
一緒に使われることが多いクラスやモジュールのみを同じコンポーネントにまとめる。
コンテナとイテレータみたいな。

実際に使わないものへの依存を強要すると、コンポーネントの使っていない部分の変更により、使う側も再デプロイする必要がある可能性がある。

インターフェース分離の原則と不要なものに依存しないようにするという点で似ている。

#### まとめ

再利用・リリース等価の原則はモジュールが大きくなるような方向性の原則である。
他方、全再利用の原則はコンポーネントを分割するような方向性の原則である。
3つの原則をバランスよくとる必要がある。
モジュールの凝集性よりも難しい概念である。

### 第14章 コンポーネントの結合

#### 非循環依存の原則

コンポーネントの依存グラフに循環依存があってはいけない。

プロジェクトが大きくなると安定版ビルドをすることが難しくなる。
他の人のソースコードを取り込む必要があるからである。
まとまった時間をとってソースコードを統合するにしても規模が大きくなるごとにその時間も大きくなる。

コンポーネントの循環依存をなくし、有向非循環グラフ構造にする。
上位コンポーネントのアップデートをリリースしたら、下位コンポーネントで新しい上位コンポーネントに対応するための開発を行う。
これを繰り返すことで、他のコンポーネントへの影響を最小限にしながら開発とリリースを行うことができる。

循環依存を解決する方法

1. 依存関係逆転の原則を適用する。
2. 新しいコンポーネントに共有して依存するクラスを移動して依存関係の方向を変える。

要件の変更に伴って依存関係の方向が変わってしまうので、絶えず気をつける必要がある。


コンポーネント図はビルド可能性や保守性を見るための図。
どこをデプロイしたらどこに影響があるのかどうかなど。
要件の変更に伴ってコンポーネント同士の依存関係は変わるので、プロジェクト開始時からコンポーネントの依存関係を設計するのは難しい。

#### 安定依存の原則

安定度の高い方向に依存する。

設計を最初から確定するのは難しい。
安定依存の原則は、設計の変化が大きいものを小さいものに依存するようにすること。
これが逆になると、変化が大きいものも変更しづらくなってしまう。

安定したコンポーネントとは多数のコンポーネントに依存されるコンポーネントのこと。
安定度はファン・アウト / （ファン・イン + ファン・アウト）
ファン・インはコンポーネント内のクラスに依存している外部のコンポーネント数のこと
ファン・アウトはコンポーネント内にある、外部のコンポーネントに依存するクラスの数のこと

万が一、安定度の低いコンポーネントに安定度の高いコンポーネントが依存していたら、依存関係逆転の原則を使って依存関係の方向をコントロールする。

#### 安定度・抽象度等価の原則

コンポーネントの抽象度は安定度と同程度にする。
安定度の高いコンポーネントは抽象モジュールで構成されるのが望ましい。
逆にいうと抽象度の高くなる方向に依存した方が良い。

抽象度はNa / Nc
Ncはコンポーネント内のクラス数のこと。
Naはコンポーネント内の抽象クラスとインターフェースの数のこと。

安定度と抽象度をプロットしてみる。
(安定度, 抽象度) =（1, 0),（0, 1)を結んだ直線を主系列と呼ぶ。
主系列との距離が小さいほどコンポーネントは望ましい。
