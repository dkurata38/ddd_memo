# クリーンアーキテクチャ

## まえがき・序文

アーキテクチャとはシステムを形作る、変更コストの大きい重要の設計決定を表したものである。

ソフトウェアとそのアーキテクチャには難しさが3つある。

1. ソフトウェアは構造の数も種類も多様である。
2. ソフトウェアアーキテクチャの本質は目に見えない。
3. 将来の開発者やユーザのニーズを満たす必要がある一方でそれはとても困難である。

将来を予測することは難しいのでソフトウェアの柔軟性を受け入れるところから始まる。

作るソフトウェアやハードウェアが時代によって変化したりしても、アーキテクチャのルールは変わらない。
本書ではそのルールについて記す。

## 第1部 ソフトウェアアーキテクチャの重要性

ソフトウェアを動かすのはそれほど難しくないが、ソフトウェアを正しくするのは難しい。
ソフトウェアを正しくすると以下のようなメリットがある。

1. 開発や保守に必要な人がはわずかで済む。
2. 変更が簡単で迅速になる。
3. 欠陥の数が少なくなる。

### 第1章 設計とアーキテクチャ

アーキテクチャと設計はそれぞれ上位レベルと下位レベルの構造や意思決定を指していると一般的に捉えられている。
実際にはアーキテクチャと設計は連続した構造を作っている。
最上位レベルから最下位レベルまで、決定の連続である。

ソフトウェアアーキテクチャの目的は、求められるシステムを最小限のコストで構築・保守するためのものである。
システム構築・保守の生産性は以下のメトリクスを確認する。

1. リリースごとのエンジニア数の増減
2. リリースごとのソースコード行数の増減
3. 1と2をもとにした、リリースごとのコード行あたりのコスト

システム開発では、リリースを急ぐあまりコードをクリーンするのを後回しにしがちである。
実際には、ソフトウェアアーキテクチャと向き合い、クリーンなコードを開発したほうが短期的にも長期的にも生産性が高い。

### 第2章 ソフトウェアの価値

ソフトウェアは振る舞いとアーキテクチャという2つの価値をステークホルダーに提供する。

#### 振る舞い

ステークホルダーの収入を増やしたり支出を減らしたりできるようにするための振る舞いを実装する。
ステークホルダーが作成した機能仕様や要件に基づいたソフトウェアを開発する。

### アーキテクチャ

ソフトウェアを簡単に変更できるような構造にする。
ソフトウェアは変更を重ねるごとに複雑になりがちだが、それとは関係なく変更の難易度がスコープに比例させることが重要である。

### 2つの価値とジレンマ

2つの価値のうち大きな価値をもつのはアーキテクチャである。
なぜなら要件が変わろうが、不具合が発生しようが、修正できさえすれば良いからである。

コードのアーキテクチャは重要性が高く、振る舞いは緊急性が高い。
ソフトウェア開発者はアーキテクチャの重要性を正しく評価することが求められる。

## 第2部

### 第3章 パラダイムの概要

#### 構造化プログラミング

直接的な制御（ジャンプ）などの制御の移行に制限をかけ、ifなどの抽象的な構文に置き換えた。

#### オブジェクト指向プログラミング

間接的な制御の移行に制限をかけた。

#### 関数型プログラミング

代入に制限をかけた。

#### まとめ

それぞれのパラダイムがアーキテクチャの関心事「コンポーネントの分離」「機能」「データ管理」に対応している。

### 第4章 構造化プログラミング

#### 数学的証明と機能分割

プログラミングに数学的な証明を持ち込もうと試行した。
goto文を使うことによって、モジュールを再起的に分割できなくなり、合理的な証明に必要な分割統治を使えなくなることがわかった。
goto文をうまく使えば、「選択」「反復」という制御構造に対応することがわかった。
プログラムを「順次」「選択」「反復」の3つの構造で構築できるとした。
この主張が認めるあれ、最近のプログラミング言語ではgoto文がサポートされなくなった。

制御構造と同様に、モジュールを証明可能な単位に分割する構造化分析が流行った。

#### 科学的な証明とテスト

数学的証明は命題が真であることを証明する一方で、科学的証明は命題が偽であることを証明する。
科学的証明の考え方はソフトウェアのテストに持ち込まれた。

ソフトウェアのテストは、バグが存在しないことを示すのではなく、存在することを示すものである。
つまり、どれだけ最善を尽くしてもバグの存在を証明できないことで、正しさを明らかにしている。

ソフトウェアテストを念頭におくと、反証可能な単位まで機能を分割していくことがアーキテクチャレベルにおいてベストプラクティスだと考えられている。

### 第5章 オブジェクト指向プログラミング

オブジェクト指向プログラミングでは「カプセル化」「継承」「ポリモーフィズム」という言葉で説明されることがある。
オブジェクト指向言語の登場により継承とポリモーフィズムを便利に扱えるようになった。

特にポリモーフィズムhz制御の流れと依存関係を逆転させることができるので、コードの依存関係をコントロールできるようになった。
アーキテクチャの視点では上位のビジネスロジック層に下層のUIやデータベースの層を依存させ、上位モジュールのデプロイを下位モジュールから独立させることができるようになった。

以下、C言語との比較。

#### カプセル化

プライベートなデータメンバーとパブリックなメンバー関数。
C言語のときからあった。
C言語ではデータ構造と関数をヘッダファイルに宣言して、ユーザからアクセスできない実装ファイルで実装をしていた。
Javaなどのオブジェクト指向言語はヘッダファイルと実装が統合されたので、カプセル化は弱体化した。

#### 継承とは

スコープないの変数と関数のグループを再度宣言するもの
オブジェクト指向言語じゃなくてもできる

C言語では多重継承するのがむずかしい。
アップキャストが暗黙的に行われる。確かにオブジェクト指向言語のほうが継承はいい感じ。

#### ポリモーフィズム

C言語にもあった
IOデバイスドライバに対して特定の関数の実装を求めることがあった。
構造体、関数ポインタ

オブジェクト指向言語によってポリモーフィズムを安全に便利にしてくれた。
C言語のときに意識する必要があった関数をポインタを経由して呼び出すという規約がなくなった。

### 第6章 関数型プログラミング

#### 不変性とアーキテクチャ

可変性は競合状態、デッドロック、並行更新などの問題を引き起こす。
可変変数がなければ並行処理を行うアプリケーションで直面する問題を回避できる。
ストレージとプロセッサの速度の観点からある程度妥協ができれば不変性は実用性がある。

#### 可変性の分離

一般的には可変コンポーネントと不変コンポーネントを分離することで妥協をする。
不変コンポーネントは可変変数を使わず関数的にタスクを行う。
不変コンポーネントは変数の状態の変更を許可しているコンポーネントと通信をする。
可変コンポーネントはトランザクショナルメモリを使用することで並行更新や競合状態から保護する。
できるだけ不変コンポーネントに処理を押し込んだほうがいい（なぜ？）

#### イベントソーシング

イベントソーシングは状態ではなくトランザクションを保存する。
状態を定期的に計算しておいて、キャッシュしておくことも可能。
イベントソーシングでは削除や更新をしない。
アプリケーションに十分な処理能力があれば関数型プログラミングを使った仕組みであると言える。

### まとめ

様々なプログラミングパラダイムにおいて、コーディングの仕方に様々な制限をかけてきた。
一方でできることは前から変わっていない。
ソフトウェアは順次、選択、反復と間接参照で構成されている。

## 第3部 設計の原則

SOLID原則を使って考える。
オブジェクト指向言語以外にも適用できる。

SOLID原則の目的は以下のような性質を持つモジュール（中間ソフトウェア）を作ること。

1. 変更に強いこと
2. 理解しやすいこと
3. コンポーネントの基盤として多くのシステムで利用できること

### 第7章 単一責任の原則

個々のモジュールを変更する理由がたった一つになるように。
モジュールはたった一人のアクター（ユーザーやステークホルダーの分類）に対して責務を負う。
モジュールとは凝集性のある関数やデータをまとめたもの。

複数のアクターに対して責務を負うと、要件や仕様の変更によるコードの変更がコンフリクトしがちである。
アクターごとにオブジェクトを用意して、アクターオブジェクトがデータに依存するようにする。
一つのデータに対して振る舞いを一つのクラスにしたい場合はFacadeクラスが複数のアクターオブジェクトに依存するようにすれば良い。

### 第8章 オープンクローズドの原則

ソフトウェアの振る舞いは既存の成果物を変更せず拡張できるようにする。
インターフェースで依存関係の方向を制御することで、ビジネスロジックを包含するような上位モジュールを下位モジュールの変更から保護することができる。
インターフェースによってモジュール内部のユーザーが直接使っていないエンティティへの推移的依存関係を防ぐことができる。

### 第9章 リスコフの置換原則

派生型を基本型に置き換えても振る舞いが変わらないようにする。
インターフェースに依存していれば派生型の実装が何であろうと振る舞いが変わらないことに依存しているから。

### 第10章 インターフェイス分離の原則

必要としないモジュールには依存しないようにする。
依存しているモジュールのうち利用していない部分が変更されたときに、再コンパイルと再デプロイをしなくてすむようにする。
複数の責務を持つクラスを実装するにしても、モジュールが利用する部分ごとにインターフェースを分離して、クラスが複数のインターフェースを実装するようにする。

### 第11章 依存関係逆転の法則

抽象宣言だけを含むソースモジュールに依存するべきである。
関数の変化しやすい実装を含む具象モジュールに依存しないようにする。

1. 変化しやすい具象クラスを参照しない。
2. 変化しやすい具象クラスを継承しない。
3. 具象関数をオーバーライドしない。

具象オブジェクトを生成するときはAbstract Factoryパターンを使う。
抽象コンポーネントを生成するファクトリの抽象にアプリケーションは依存し、ファクトリの具象が具象オブジェクトを生成する。

## 第4部 コンポーネントの原則

### 第12章 コンポーネント

コンポーネントはデプロイの最小単位のことである。

### 第13章 コンポーネントの凝集性

#### 再利用・リリース等価の原則

再利用の単位とリリースの単位は等価になる。
コンポーネントを形成するクラスやモジュールは凝集性のあるグループである。
一つのコンポーネントを形成するクラスやモジュールはまとめてリリース可能である。

#### 閉鎖性共有の原則

単一責任の原則のコンポーネントバージョン。
異なる理由、異なるタイミングで変更されるクラスはの別のコンポーネントに分けること。
同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめること。
このようにすればリリース時の作業を最小限にできる。
オープンクローズドの原則とも関連している。

#### 全再利用の原則

コンポーネントのユーザに対して実際に使わないものへの依存を強要してはいけない。
一緒に使われることが多いクラスやモジュールのみを同じコンポーネントにまとめる。
コンテナとイテレータみたいな。

実際に使わないものへの依存を強要すると、コンポーネントの使っていない部分の変更により、使う側も再デプロイする必要がある可能性がある。

インターフェース分離の原則と不要なものに依存しないようにするという点で似ている。

#### まとめ

再利用・リリース等価の原則はモジュールが大きくなるような方向性の原則である。
他方、全再利用の原則はコンポーネントを分割するような方向性の原則である。
3つの原則をバランスよくとる必要がある。
モジュールの凝集性よりも難しい概念である。

### 第14章 コンポーネントの結合

#### 非循環依存の原則

コンポーネントの依存グラフに循環依存があってはいけない。

プロジェクトが大きくなると安定版ビルドをすることが難しくなる。
他の人のソースコードを取り込む必要があるからである。
まとまった時間をとってソースコードを統合するにしても規模が大きくなるごとにその時間も大きくなる。

コンポーネントの循環依存をなくし、有向非循環グラフ構造にする。
上位コンポーネントのアップデートをリリースしたら、下位コンポーネントで新しい上位コンポーネントに対応するための開発を行う。
これを繰り返すことで、他のコンポーネントへの影響を最小限にしながら開発とリリースを行うことができる。

循環依存を解決する方法

1. 依存関係逆転の原則を適用する。
2. 新しいコンポーネントに共有して依存するクラスを移動して依存関係の方向を変える。

要件の変更に伴って依存関係の方向が変わってしまうので、絶えず気をつける必要がある。


コンポーネント図はビルド可能性や保守性を見るための図。
どこをデプロイしたらどこに影響があるのかどうかなど。
要件の変更に伴ってコンポーネント同士の依存関係は変わるので、プロジェクト開始時からコンポーネントの依存関係を設計するのは難しい。

#### 安定依存の原則

安定度の高い方向に依存する。

設計を最初から確定するのは難しい。
安定依存の原則は、設計の変化が大きいものを小さいものに依存するようにすること。
これが逆になると、変化が大きいものも変更しづらくなってしまう。

安定したコンポーネントとは多数のコンポーネントに依存されるコンポーネントのこと。
安定度はファン・アウト / （ファン・イン + ファン・アウト）
ファン・インはコンポーネント内のクラスに依存している外部のコンポーネント数のこと
ファン・アウトはコンポーネント内にある、外部のコンポーネントに依存するクラスの数のこと

万が一、安定度の低いコンポーネントに安定度の高いコンポーネントが依存していたら、依存関係逆転の原則を使って依存関係の方向をコントロールする。

#### 安定度・抽象度等価の原則

コンポーネントの抽象度は安定度と同程度にする。
安定度の高いコンポーネントは抽象モジュールで構成されるのが望ましい。
逆にいうと抽象度の高くなる方向に依存した方が良い。

抽象度はNa / Nc
Ncはコンポーネント内のクラス数のこと。
Naはコンポーネント内の抽象クラスとインターフェースの数のこと。

安定度と抽象度をプロットしてみる。
(安定度, 抽象度) =（1, 0),（0, 1)を結んだ直線を主系列と呼ぶ。
主系列との距離が小さいほどコンポーネントは望ましい。

## 第5部 アーキテクチャ

ソフトウェアアーキテクチャとは
構築した人がシステムに与えた形状のこと

形状の目的は、ソフトウェアシステムの開発、デプロイ、運用、保守を容易にすることである。
できるだけ長い期間、できるだけ多くの選択肢を残すことである。
残すべき選択肢というのは重要ではない詳細のこと。

詳細に影響のない方針
詳細は、IOデバイス、データベース、ウェブ、サーバー、フレームワーク、通信プロトコルなど。

アーキテクチャによって開発チームが開発しやすくなるようなシステムにする。
単一のアクションで簡単にデプロイできるようにすること。
開発者がアーキテクチャを見れば簡単に運用方法をわかるようにする。
機能を追加したり欠陥を修正したりする場所や戦略を簡単に見つける。

### 第16章 独立性

アーキテクチャがサポートする様々なことをバランスをとるのが難しい。
またユースケース、制約、チーム構造、デプロイ要件などを全てをあらかじめ知ることは難しい。
適切なルールのもと独立したコンポーネントに分割することで多くの選択肢を残すことができる。

#### 分離の仕方

アーキテクチャはシステムの意図をサポートする。
ユースケースにとって重要なものがアーキテクチャで目立った位置を占める。
21章で詳しく説明する。

##### レイヤーの切り離し

水平レイヤーによる分割
異なる理由で変更されるものを分離し、同じ理由で変更されるものをまとめる。
UIの変更によってビジネスルールが変更されることはない。
UIとビジネスルールは切り離したほうがいい。
他にも技術的詳細をビジネスルールから切り離す。

##### ユースケースの切り離し

ユースケース同士も独立している。変更する理由が異なるから。
新しいユースケースの追加も変更も他のユースケースに影響を与えない。

#### 重複

コードの重複
インスタンスの重複

重複が本当に重複なのか。
ユースケースが異なるのにコードを共通化した場合、後々別物になり変更を修正するのが難しくなる。

#### 分離レベル

異なるサービス間はネットワークパケットだけで通信をする。
ソースやバイナリを変更しても互いに影響を与えることはない。
どのレベルで分離するかを初期に判断するのは難しい。
分離レベルが高いほど労力やハードウェアリソースの消費が激しくなる。

##### ソースレベル（開発）

モジュール間の依存性を管理する。
コンポーネント間の通信は単純な関数呼び出しを使用する。
メモリに読み込まれた単一の実行ファイルが存在する。
モノリシック構造
コンポーネントが明確に開発されていれば、コンポーネントごとにチームを分けて開発をすることができる。
システムを設計する組織は組織のコミュニケーション構造をコピーした構造の設計を生み出す。

##### デプロイレベル

モジュールのソースコードに対する変更が他のモジュールの再ビルドや再デプロイにつながらないようにする。
コンポーネントは単独でデプロイ可能な単位で分離される。
構築後すぐにデプロイできる。
ユースケースやレイヤーが適切に分離されていればそれぞれのコンポーネントを独立してデプロイできる。

##### サービスレベル

本質的な役割を果たす。
システムのユースケースの非機能要件をサポートする。
具体的にどのようにサポートするかは選択肢として残す。
例えばモノリシックにもマイクロサービスにも簡単に移行できるようにする。

運用レベルでユースケースの切り離しを行う場合は、コンポーネントをそれぞれ異なるサーバーにデプロイして何らかの通信手段でやりとりを行う。
サービス指向アーキテクチャやマイクロサービシズと呼ばれる。

### 第17章 バウンダリー

ソフトウェアの要素をお互いに分離し、お互いのことがわからないように制限する

早すぎる決定との結合
ビジネス要件と関係のない決定との結合。
フレームワーク、データベース、ウェブサーバー、ライブラリなど。
優れたシステムアーキテクチャはこの決定を従属的かつ遅延可能なものにする。

ビジネスルールにとって「重要なもの」と「重要ではないもの」の境界線を引く。
ビジネスルールの変更とそれ以外のものは変更のタイミングや頻度が違う。
重要でないものを差し替え可能なコンポーネントにできるように作り込むのがプラグインアーキテクチャ。

#### プラグインアーキテクチャ

DIP
SRP
SAP

### 第18章 境界の解剖学

#### 境界を越える

実行時に境界を越えるには境界の向こう側にある関数呼び出しとデータの受け渡し。
適切な境界を越えるにはソースコードの依存関係を管理する必要がある。
あるモジュールを変更したとき

#### モノリス

デプロイの観点でモノリスだったとしても、境界が全く存在しないというわけではない。
実行時もコンパイル時も上位コンポーネントに依存するようにする。
デプロイコンポーネント間の通信も単なる関数呼び出しなので安価である。

#### スレッド

モノリスとデプロイコンポーネントの両方でスレッドを使用できる。
実行のスケジュールや順序を整理する方法。
モノリスとデプロイコンポーネントの両方でスレッドを使用できる。
スレッドは一つのコンポーネントに含めることもできるし複数のコンポーネントに分散させることもできる。

#### ローカルプロセス

プロセス間の通信はソケットかメールボックス、メッセージキューなどのOSの通信機能を使って行われる。
ローカルプロセスは上位コンポーネントの一種。
上位レベルのプロセスには下位レベルのプロセスの物理的な情報がない。
コンテキストスイッチやシステムコールなどによって境界を越える。

#### サービス

あらゆる通信はネットワーク経由で行われる。
関数呼び出しに比べると圧倒的に遅い。
上位レベルのサービスには下位レベルのサービスの情報を含めてはいけない。

システムの境界にはローカルな境界とレイテンシーに影響される境界が混ざっている。

### 第19章 方針とレベル

単一責任の原則、閉鎖性共通の原則
方針は変更方法に基づいてコンポーネントにグループ化されている
異なる理由や時期に変更する方針は、異なるレベルのコンポーネントに分けておく。

オープンクローズドの原則

レベルの定義は「入力と出力からの距離」

依存関係逆転の原則
安定依存の原則
安定度・抽象度等価の原則
データフローとソースコードの依存性は必ず同じ方向を指しているは限らない。

### 第20章 ビジネスルール

ビジネスルール
ビジネスマネーを生み出したり節約したりするルールや手続き
コンピュータの実装に依存しない
最重要ビジネスルール

最重要ビジネスルールで必要なデータを最重要ビジネスデータという
最重要ビジネスデータはオブジェクトの有力な候補になる。
これらのオブジェクトをエンティティと呼ぶ

エンティティ
コンピュータシステム内部のオブジェクト
最重要ビジネスデータを操作する最重要ビジネスルールを含んだもの
最重要ビジネスデータもしくはそれへのアクセス手段

ユースケース
自動化されたシステムを定義・制限することによってビジネスのお金を生み出したり節約するビジネスルール
アプリケーション固有のビジネスルール
最重要ビジネスルールをいつどのように呼び出すかというルールが含まれている

リクエストとレスポンス
ユースケースの入力と出力
Webに対する責務はない

ビジネスルールに関するコードがシステムの心臓部になる。何も配慮しないことが理想である。

### 第21章 叫ぶアーキテクチャ

アーキテクチャはユースケースについて叫ぶべきである。
フレームワーク、データベース、ウェブサーバーなどの意思決定を留保できる。
Webアプリケーションにするかどうかも留保できる。
ユースケースがフレームワークから分離されていればフレームワークがなくてもそのままの状態でテスト可能である。

### 第22章 クリーンアーキテクチャ

ヘキサゴナルアーキテクチャ『実践テスト駆動開発』
DCIアーキテクチャ
BCE『オブジェクト指向ソフトウェア工学OOSE』

ソフトウェアをレイヤーの分離することで関心の分離（ビジネスルール、システムとのインターフェースなど）
特徴
フレームワーク非依存
テスト可能
UI非依存
データベース非依存
外部エージェント非依存

#### エンティティ

最重要ビジネスルールをカプセル化したもの
オブジェクトか関数かどうかは問わない
外部で変化が起きても、エンティティが変わる可能性は低い

#### ユースケース

ユースケースにはアプリケーション固有のビジネスルールが含まれている。
システムすべてのユースケースがカプセル化・実装されている。
アプリケーションの操作の変更やエンティティの変更によってソースコードが変更されることがある。

#### インターフェースアダプター

ユースケースやエンティティの便利なフォーマットから外部エージェントに便利なフォーマットに変換する。
JSONとの変換とか、DBに保存するオブジェクトとか。

#### フレームワークとドライバ

フレームワークやデータベースなどの技術的な詳細は1番外側。

#### 境界線を越える

インターフェースなどを使って依存関係を整理する。
境界線を越えるデータは単純なデータ構造で構成されている。
関数の引数や戻り値に使うことができる。
依存性のルールに違反するようなデータ構造を持たせたくはない。

### 第23章 テストとHumble Objectパターン

#### Humble Objectパターン

ユニットテストをしやすい振る舞いと、ユニットテストをしづらい振る舞いを分割する
ViewもしくはGUIはユニットテストをしづらい。
Presnterはテスト可能なオブジェクトである。

このようなテストしやすい振る舞いとテストしづらい振る舞いの境界もアーキテクチャ境界の定義につながる。

データベースゲートウェイはインターフェース。
ユースケースからはゲートウェイのメソッドを呼び出す。
データベースレイヤーにデータベース依存のコードを分離することでユースケースをテスト可能にできる。
データマッパーはデータベースゲートウェイとデータベースの間にHumbleオブジェクトの境界を作るもの。
外部サービス連携するところでもHumble Objectパターンを使うことができる。

### 第24章 部分的な境界

厳格なアーキテクチャの境界は、依存性管理や両面にインターフェースを作成する必要があるなどコストが高い。
そのようなコストを払ってでもそのような境界を作る必要があるかはわからない。
そこで部分的な境界を一部で取り入れることにした。
ただ、完全な境界ではない以上開発中に境界が劣化していく恐れがある。


#### 複数コンポーネントをまとめる

複数コンポーネントをまとめてデプロイすることで依存性管理が楽になる。


#### 片方だけの境界

クライアントが境界インターフェースに依存することで依存性をコントロールする
しかし境界インターフェースの実装クラスがクライアントを参照することもできてしまう

#### Facade

クライアントがFacadeに依存して、Facadeが実装クラスを呼び出し分ける。
推移的依存関係ができてしまう。

### 第25章 レイヤーと境界

アーキテクチャ境界は変更の軸によって定義される。
情報の流れは上位コンポーネントに集約されることが多い。

### 第26章 メインコンポーネント

Mainコンポーネントは他のコンポーネントを作成、調整、監督するコンポーネントである。
Mainコンポーネントはシステム最初のエントリポイント。
Mainはアプリケーションのプラグイン。
初期状態や構成を設定して、外部リソースを集め、アプリケーションの上位レベルの方針に制御を渡す。

### 第27章 サービス

#### サービスアーキテクチャ

サービスは単なる関数呼び出しにすぎず、アーキテクチャの中で最重要というわけではない。

#### 分離

システムをサービスごとに分けると、サービス同士が強く分離される。
プロセッサ内やネットワーク上にある共有リソースは分離されていない。
サービスごとに分離したとしてもデータを通じて強く結びついてしまっている。

#### チームとデプロイの独立

正しくサービスを分離できている場合、サービスごとにチームを独立させて運用できる。
ただし、上記のようなシステムはモノリシックなシステムでも可能である。

#### コンポーネントベースのサービス

jarを追加するだけで機能を拡張することができる。

### 第28章 テスト境界

テストはシステムの一部

テストは依存性のルールに従う
テストはテストをするコードに強く依存している

テスト容易性を高めるためには結合を防ぐ必要がある。
1箇所のコードを変更であっても、多くのシステムやテストを変更する必要が発生する可能性がある。
変化しやすいものに依存しないテストを作る

テストAPIの目的はアプリケーションの構造からテストの構造を切り離すこと。
テストAPIはアプリケーションの構造をテストから隠すこと。

### 第29章 クリーン組み込みアーキテクチャ

ソフトウェアは劣化しなくとも、ファームウェアやハードウェアは劣化する。
ソフトウェアとファームウェアを分離して考える。

## 第4部 詳細

### 第30章 データベース

データの構造は重要だが、データベースソフトウェアは重要ではない。

#### リレーショナルデータベース

データを表形式で扱うかどうかはユースケースにとって重要ではない。
データアクセスフレームワークの多くはデータベースの行やテーブルをオブジェクトとして受け渡しをする。
このオブジェクトをそのまま使うとUIやビジネスルールがリレーショナルデータ構造に依存してしまう。
これを防ぐ必要がある。

#### データベースとは

データベースはディスクとRAMを使って高速にデータを操作するための仕組み。
データモデルよりも技術的関心事に近い。

### 第31章 Web

WebはGUIであり、入出力デバイスの一つである。
Webとビジネスロジックを切り離してデバイス非依存にする。

#### 技術的な要因

Webは計算処理を中央サーバーに集中させるか端末に分散させるかの行ったり来たりの延長線上にあるもの。
技術の進歩や流行によって計算処理を行う場所が変わる。

1. サーバーに集中
2. コンテンツの一部がアプレットに移行
3. 動的コンテンツが再びサーバー側に移行
4. AjaxとJavaScriptによって処理の一部がブラウザに移行
5. Node.jsでJavaScriptの処理をサーバー側に移行

#### 要求に紐づく要因

マーケティングに関する都合でUIや画面の振る舞いに関する変更が相次ぐ。
