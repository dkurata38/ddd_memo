# クリーンアーキテクチャ

## まえがき・序文

アーキテクチャとはシステムを形作る、変更コストの大きい重要の設計決定を表したものである。

ソフトウェアとそのアーキテクチャには難しさが3つある。

1. ソフトウェアは構造の数も種類も多様である。
2. ソフトウェアアーキテクチャの本質は目に見えない。
3. 将来の開発者やユーザのニーズを満たす必要がある一方でそれはとても困難である。

将来を予測することは難しいのでソフトウェアの柔軟性を受け入れるところから始まる。

作るソフトウェアやハードウェアが時代によって変化したりしても、アーキテクチャのルールは変わらない。
本書ではそのルールについて記す。

## 第1部 ソフトウェアアーキテクチャの重要性

ソフトウェアを動かすのはそれほど難しくないが、ソフトウェアを正しくするのは難しい。
ソフトウェアを正しくすると以下のようなメリットがある。

1. 開発や保守に必要な人がはわずかで済む。
2. 変更が簡単で迅速になる。
3. 欠陥の数が少なくなる。

### 第1章 設計とアーキテクチャ

アーキテクチャと設計はそれぞれ上位レベルと下位レベルの構造や意思決定を指していると一般的に捉えられている。
実際にはアーキテクチャと設計は連続した構造を作っている。
最上位レベルから最下位レベルまで、決定の連続である。

ソフトウェアアーキテクチャの目的は、求められるシステムを最小限のコストで構築・保守するためのものである。
システム構築・保守の生産性は以下のメトリクスを確認する。

1. リリースごとのエンジニア数の増減
2. リリースごとのソースコード行数の増減
3. 1と2をもとにした、リリースごとのコード行あたりのコスト

システム開発では、リリースを急ぐあまりコードをクリーンするのを後回しにしがちである。
実際には、ソフトウェアアーキテクチャと向き合い、クリーンなコードを開発したほうが短期的にも長期的にも生産性が高い。

### 第2章 ソフトウェアの価値

ソフトウェアは振る舞いとアーキテクチャという2つの価値をステークホルダーに提供する。

#### 振る舞い

ステークホルダーの収入を増やしたり支出を減らしたりできるようにするための振る舞いを実装する。
ステークホルダーが作成した機能仕様や要件に基づいたソフトウェアを開発する。

### アーキテクチャ

ソフトウェアを簡単に変更できるような構造にする。
ソフトウェアは変更を重ねるごとに複雑になりがちだが、それとは関係なく変更の難易度がスコープに比例させることが重要である。

### 2つの価値とジレンマ

2つの価値のうち大きな価値をもつのはアーキテクチャである。
なぜなら要件が変わろうが、不具合が発生しようが、修正できさえすれば良いからである。

コードのアーキテクチャは重要性が高く、振る舞いは緊急性が高い。
ソフトウェア開発者はアーキテクチャの重要性を正しく評価することが求められる。

## 第2部

### 第3章 パラダイムの概要

#### 構造化プログラミング

直接的な制御（ジャンプ）などの制御の移行に制限をかけ、ifなどの抽象的な構文に置き換えた。

#### オブジェクト指向プログラミング

間接的な制御の移行に制限をかけた。

#### 関数型プログラミング

代入に制限をかけた。

#### まとめ

それぞれのパラダイムがアーキテクチャの関心事「コンポーネントの分離」「機能」「データ管理」に対応している。

### 第4章 構造化プログラミング

#### 数学的証明と機能分割

プログラミングに数学的な証明を持ち込もうと試行した。
goto文を使うことによって、モジュールを再起的に分割できなくなり、合理的な証明に必要な分割統治を使えなくなることがわかった。
goto文をうまく使えば、「選択」「反復」という制御構造に対応することがわかった。
プログラムを「順次」「選択」「反復」の3つの構造で構築できるとした。
この主張が認めるあれ、最近のプログラミング言語ではgoto文がサポートされなくなった。

制御構造と同様に、モジュールを証明可能な単位に分割する構造化分析が流行った。

#### 科学的な証明とテスト

数学的証明は命題が真であることを証明する一方で、科学的証明は命題が偽であることを証明する。
科学的証明の考え方はソフトウェアのテストに持ち込まれた。

ソフトウェアのテストは、バグが存在しないことを示すのではなく、存在することを示すものである。
つまり、どれだけ最善を尽くしてもバグの存在を証明できないことで、正しさを明らかにしている。

ソフトウェアテストを念頭におくと、反証可能な単位まで機能を分割していくことがアーキテクチャレベルにおいてベストプラクティスだと考えられている。
